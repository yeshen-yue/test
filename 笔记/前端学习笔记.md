# 常犯错误总结
1. 
```
var scope = "window";
function fn(){
    console.log(scope);
}
function gn(){
    var scope = "gn";
    fn();
}
gn(); // ?
```
2. 
```
var a = 1;
        function fn(a) {
            a = 2;
        }
        fn(a);
        console.log(a);  //a依然为1
```
3. 
```
function fn(num){
    console.log(num);
    function num(){

    }
    var num="hello";
}
fn(10); //输出结果是fn(){}
```
4. 
```
arr.sort(升序排)
console.log(arr)
arr.sort(降序排)
console.log(arr)
//因为浏览器展示的是数组的折叠值，在你展开的过程相当于重新从堆中获取这个引用类型值，而这个时候arr已经是降序排完之后的了，所以以上两个log都会输出降序排的arr
```
5. 
```
var a=1;
function a(){
    console.log(a); //输出function
}
```
6. 
```
`<button onclick="removeUser('${data.list.userId}')">`
```
*注*：利用反引号插入元素时，其行内click中函数的变量是字符串时需要手动加引号。因为此时${}处于括号中，即使${}是字符串，也不会加上引号。
7. 
```
 var name = "libai";
        {
            console.log(name);//会报错，不会输出liabai，如果没有let，则会输出libai。暂时性死区
            let name = "dufu";
        }
```
8. console.log([]== 0);  // true
# 涨知识
1. 
```
 <input type="text" name="user" value="" v-module="name">
        <input type="text" name="user" value="" v-module="age">
    <script>
        var iptEle = document.querySelectorAll("input");
        let data = {};
        for (var i = 0; i <= 1; i++) {
            (function (i) {
                var key = iptEle[i].getAttribute("v-module");
                Object.defineProperty(data, key, {
                    get() { return iptEle[i].value; },
                    set(v) { iptEle[i].value = v }
                })
            }(i));
        }
    </script>
```
2. 
```
function fixedFnMake(fn, ...args) {
             return function () {
                 fn.apply(this, args);
             }
            return fn.bind(this, ...args);
            //对比以上两者的区别，前者的this是可活动的，是指向后来的调用者user；而后者的this已经被绑定为fixedFnMake的调用者window了
        }
        user.saytimefixed = fixedFnMake(saytime, "6:00", "sing");
        user.saytimefixed();
```
3. 批处理重命名文件
```
@echo off
cd /d %~dp0
setlocal enabledelayedexpansion
set num=1
for %%i in (*.png) do (
ren "%%i" "!num!.png"
set /A num=!num!+1
)
```
4. 十万条数据分页加载，配合文档碎片fragment
```
const render = (page) => {
        if (page >= totalPage) return
        requestAnimationFrame(() => {
            // 创建一个文档碎片
            const fragment = document.createDocumentFragment()
            for (let i = page * limit; i < page * limit + limit; i++) {
                const item = list[i]
                const div = document.createElement('div')
                div.className = 'sunshine'
                div.innerHTML = `<img src="${item.src}" /><span>${item.text}</span>`
                // 先塞进文档碎片
                fragment.appendChild(div)
            }
            // 一次性appendChild
            container.appendChild(fragment)
            render(page + 1)
        })
    }

```
# 网站概述

1. 网站:在因特网上利用HTML等规则展示特定内容的网页集合
2. 网页:网站中的一页,通常是需要浏览器来阅读的HTML文件,是网站的基本元素,由图片、链接、文本等组成。
3. HTML：超文本标记语言（Hyper Text Markup Language)
    * 可以加入图片、声音、动画（超越文本限制）
    * 从一个文件跳转到另一个文件，与各地主机链接（超级链接文本）
4. 网页的形成：前端人员开发代码->浏览器显示代码（解析，渲染）->生成最后的页面
5. 浏览器内核：渲染引擎，负责读取网页内容，整理讯息。最常见内核：webkit 和 Blink
6. Web标准：有w3c组织和其他标准化组织制定的一系列标准集合。主要作用是统一不同浏览器排版和显示的差异。
   包括三个方面：
   * 结构：对网页元素进行整理和分类
   * 表现：用于设置网页元素的版式、颜色等外观，如CSS
   * 行为：网页模型的定义及交互的编写，例如javascript
# VS Code
1. <!DOCTYPE>文档类型声明标签（放在文档最前面，不属于HTML标签）声明使用哪种HTML版本
2. `<html lang="en">`定义文档显示的语言，"zh-CN"为中文网页
3. `<meta charset="UTF-8"/>`规定HTML文档应该使用哪种字符编码，常用值有：GB2312,BIG5,GBK和UTF-8,UTF-8被称为万国码，包含所有国家需要用的字符，不写该标签可能会乱码

# HTML
## 基本结构标签
1. 根标签：<html></html>
2. 头部标签：<head></head>
3. 标题标签：<title></title>
4. 主体标签：<body></body>
5. 下标：<sub></sub>
6. 上标：<sup></sup>
7. 引用：<q></q>
8. 大段引用<blockquote></blockquote>
9. 水平线标签<hr>
10. 标题标签<h1></h1>-<h6></h6>
11. 段落<p></p>
12. 换行<br></br>
13. 文本格式化标签
    * 加粗<strong></strong>或<b></b>
    * 倾斜<em></em>或<i></i>
    * 删除线<del></del>或<s></s>
    * 下划线<ins></ins>或<u></u>
14. div 和 span
15. 图像标签`<img src="图像URL" alt="替换文本">`
16. 超链接标签`<a href="跳转目标" target="目标窗口的弹出方式"></a>`
a为anchor缩写，target取值：
_self默认值，在当前窗口打开
_ blank为新窗口打开方式
17. 注释标签，ctrl+/
18. 特殊字符
空格 `&nbsp;``&ensp;``&emsp;`
"<" `&lt;`(less than)
">" `&gt;`(greater than)
## 表格
1. 基本语法
```html
<table>
    <tr>
        <th>姓名</th>
    </tr>
    <tr>
        <td>单元格内的文字</td>
    </tr>
</table>
```
2. 表格属性
<table>
    <tr>
        <th>属性名</th><th>属性值</th><th>作用</th>
    </tr>
    <tr>
        <td>align</td><td>left,center,right</td><td>表格的对齐方式</td>
    </tr>
    <tr>
        <td>border</td><td>1或者""</td><td>表格单元格边框，默认无</td>
    </tr>
    <tr>
        <td>cellpadding</td><td>像素值</td><td>内容与单元格边界的空白，默认1像素</td>
    </tr>
    <tr>
        <td>cellspacing</td><td>像素值</td><td>单元格之间的空白，默认为2像素</td>
    </tr>
    <tr>
        <td>width</td><td>像素值或百分比</td><td>规定表格宽度</td>
    </tr>
</table>

3. 合并单元格
    * 跨行合并 rowspan=“合并单元格个数”
    * 跨列合并 colspan="合并单元格个数“
    合并后记得在原表格标签中删除多余单元格

## 列表
1. 无序列表
```html
<ul>
    <li>列表项</li>
    <li>列表项</li>
<ul>
```
2. 有序列表
```html
<ol>
    <li>列表项</li>
    <li>列表项</li>
</ol>
```
3. 自定义列表
```html
<dl>
    <dt>名词</dt>
    <dd>名词解释</dd>
    <dd>名词解释</dd>
</dl>
```
## 表单域
1. 表单的组成：表单域、表单控件（表单元素）、提示信息
2. "<form>"标签用于定义表单域，会把范围内的表单元素信息提交给服务器
```html
<form action="url地址" method="提交方式" name="表单域名称">                             
    各种表单元素控件
</form>
```
3. input表单元素
    * type属性：text文本框 password密码框 radio单选按钮 checkbox复选框 reset重置 submit提交
               button普通按钮 file提交文件 value
    * 新增type属性：multiple提交多文件 email date number（可设置min max step) search（都必须在表单域中才能生效）
    * name属性：要实现单选或多选，必须给每一个radio和checkbox设置相同的name值
    * checkek属性：首次加载时必须被选中
    * maxlength属性：输入字符的最大长度
    * autocomplete="on/off",自动填充历史对象
    * autofocus="to"，自动光标定位
    * disabled="disabled",控件不可用
    * readonly="readonly",控件只为可读状态，无法输入内容
    * placeholder 在可输入控件中预设文本信息，如提示用户输入邮箱
    *注*：修改placeholder样式可以用`input::placeholder{color:pink;}`
4. label标签：用于绑定一个表单元素，当点击label内的文本时，会自动聚焦到相应的表单元素上
```html
<label for="sex">男</label>
<input id="sex">
```
5. select表单元素
```html
<select>
    <option>选项1</option>
    <option>选项2</option>
</select>
```
6. "<textarea>"文本域标签
`<textarea rows="3" cols="20"></textarea>`
7. 表单补充：
    * 去掉input的默认蓝色边框`input{outline:0 | none;}`
    * 防止文本域拖拽`textarea{resize:none;}`

8. 表单name属性在dom中的妙用：form和input都定义name属性后，可直接利用document.form1.inpu1得到 input元素

   ```
   <form action="" name="form1">
     <input class="input" name="input1" type="text" value="我是input的内容" />
   </form>
   <script>
     var input = document.querySelector(".input");
     input.onclick = function () {
       if (document.form1.input1.focus) {
         document.form1.input1.select();//实现光标聚集时自动选中文本
       }
     };
   </script>
   ```

   

## 路径相关知识 

1. 相对路径
    * 同级直接写文件名
    * 下一级 images/.....
    * 上一级 ../
2. 绝对路径
src="D:\baidudownload\images\回忆\"或者是网络链接
## HTML5新增标签
1. header, footer , nav, article , section , audio ,video
2. **视频标签**：
`<video src="" width="" height=""></video>`
autoplay自动播放 controls向用户展示播放控件 muted静音播放 loop循环播放 poster加载时等待界面
*注*：谷歌浏览器必须添加muted属性才能自动播放
3. **meter标签**：`<meter value="81" min="0" max="100" low="60" high="80"></meter>`
6. **进度条标签**：`<progress value="22" max="100"></progress> `
# css
## css三大形式
1. 内部样式表：直接写在html文件内部的style里面
2. 行内样式表：在元素标签内部的style属性中设定css样式
3. 外部样式表：单独写到css文件中，之后把css文件引入到HTML页面中使用
```html
<head>
    <link rel="stylesheet" href="css文件路径">
</head>
```
## css三大特性
1. 层叠性：相同选择器设置相同特性，遵循就近原则；
2. 继承性：子标签会继承父标签的某些样式，主要是text-, font-, line- 等文字类样式
3. 优先级：根据选择器权重执行样式
## 选择器
### 基础选择器
1. 标签选择器
    标签名{}
2. 类选择器
    .类名{}
3. id选择器
    \#id名{}
4.  通配符选择器
    *{}
### 复合选择器
1. 后代选择器 div p{} (选择后代中的所有p标签)
2. 子选择器 div>p{} （只选择第一代的p标签）
3. 并集选择器 div,p{}
4. 伪类选择器
    a:link 选择所有未被访问的链接
    a:visited 选择所有已被访问的链接
    a:hover 选择鼠标停留的链接
    a:active 选择活动链接（鼠标按下未弹起的链接）
    input:checked 多选框被选中
    input:focus 获取焦点的表单元素
### 新增选择器
1. 属性选择器
```
input[value]{} //含有value属性的input元素，权重为11
input[value=""]{} //value属性等于特定值的input元素
input[value^=""]{} //value属性*开头*等于特定值的input元素
input[value$=""]{} //value属性*结尾*等于特定值的input元素
input[value*=""]{} //value属性含有特定值的input元素
```
2. nth-child()和nth-of-type()
```
section div:nth-child(1) //先找是父类第一个孩子的元素，再看前面的选择器条件
section div:nth-of-type(1) //先找前面的，再判断是否为父类的第一个div
nth-child(-n+5) //n必须写在前面，n从0开始计算，表示选择第1-5个子元素
nth-last-child(-n+5) //从后面开始算起，表示选择最后面五个子元素
```
3. first-child、last-child和first-of-type、last-of-type
4. 伪元素选择器
`::before{}`在元素前部插入内容
`::after{}`在元素后部插入内容
语法：`element::before{content:"";}`
*注*：content为必须属性，插入的是行内元素，必须转换模式才有宽高
### 选择器权重
<table>
<tr><th>选择器</th><th>权重</th></tr>
<tr><td>继承或者*</td><td>0，0，0，0</td></tr>
<tr><td>元素选择器</td><td>0，0，0，1</td></tr>
<tr><td>类选择器，伪类选择器，属性选择器</td><td>0，0，1，0</td></tr>
<tr><td>ID选择器</td><td>0，1，0，0</td></tr>
<tr><td>行类样式</td><td>1，0，0，0</td></tr>
<tr><td>!important</td><td>无穷大</td></tr>
</table>
*注*：复合选择器权重叠加，但是不管如何叠加都不会有进位
ul li{}权重为0001+0001=0002
.nav li{}权重为0010+0001=0011
a:hover{}权重为0001+0010=0011

## css字体属性
1. 字体font-family:"微软雅黑",Arial,"San-serif";
可设置多个字体，用逗号隔开，计算机会优先识别第一个。两个单词时要加引号
2. 字体大小font-size: 20px;
谷歌浏览器默认字体大小为16px;
3. 字体粗细font-weight: normal或者400|bold或者700
4. 字体样式 font-style:normal默认值|italic斜体
5. 字体复合属性font:font-style font-weight font-size/line-height font-family;(顺序不能颠倒)
## css文本属性
1. 文本颜色color:pink|#cc00ff|rgb(0,0,0);
2. 水平对齐text-align:center|left|right;
3. 文本装饰text-decoration: none默认|underline下划线|overline上划线|line-through删除线
4. 缩进text-index:20px|2em;
5. 行高line-height
6. 字间距letter-spacing
7. 词间距word-spacing
## css背景属性
1. 背景颜色 background-color:transparent;
2. 背景图片 background-image: none | url();
3. 背景平铺 background-repeat: repeat(默认) | no-repeat | repeat-x | repeat-y
4. 背景图片位置 background-position: 20px 50px ;（前者为 x轴坐标，后者为y轴坐标，若只写一个，则另一个默认居中）
也可用方位名词：top,center,bottom,left,center,right
或者坐标和方位名词混用：background-position: 20px center
background-position-x  只调节x轴
5. 背景大小 background-size: 50px 60px;
cover:把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。*注*：按原比例扩大
contain:把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。*注*：不按原比例扩大，直接拉满整个屏幕
6. 背景图像固定（背景附着）
background-attchment: scroll(默认) | fixed;
7. 背景复合写法，无顺序要求。约定顺序为：颜色，图片地址，平铺，图像滚动，图片位置
background: transparent url() repeat-y fixed top;
8. 背景色半透明写法：background: rgba(0,0,0,0.3)或者rgba(0 0 0/.3)
9. 背景线性渐变
`background: linear-gradient(to right,red 60%, orange 80%)`
背景线性重复渐变
`background:repeating-linear-gradient(to right, red 0 10%, purple 10% 20%)`
*注*：第一个参数也可以是角度
10. 径向渐变
`radial-gradient(shape? size? at position? ,star-color, ...last-color)`
shape:circle | ellipse
size:一个值默认为圆半径，且不能为百分比；两个值为椭圆，可以为百分比
11. background-origin:border-box | padding-box | content-box
设置背景从哪里开始渲染
12. background-clip裁切背景，取值同上
13. 以逗号分割多背景
```
background:url("img/1.jpg") no-repeat left top,
url(img/2.jpg) no-repeat right top;
```
## 3D变换
1. perspective 实例:`perspective:1000px`
    * 作为一个属性设置给父元素，作用于所有3D转换子元素
    * 作为transform属性的一个值作用于元素自身
2. transform-style: preserve-3d 默认值为float。旨在告诉子元素需要遵循怎样的空间体系规则
## transform
`transform:translate scale rotate skew;`
translate(30px,40px)水平位移30px,垂直位移40px
scale(0.5)大小缩小为原来的一半
transform-origin设置旋转中心，如left center 或80% 60%
## transition
`transition:all 0.4s（过渡时间） 0.1s（延迟时间） ease-in`

## 元素的显示模式
1. 块元素：h1 p div ul ol li
特点；独占一行；高宽、内外边距都可以控制；宽度默认为父元素的100%；里面可以放行内或块级元素
*注*文字内元素如p和h1里面不能放其他块级元素
2. 行内元素：a strong b em i del s ins u span
特点：一行可以显示多个；宽高及上下内外边距设置无效；默认宽度是内容宽度；行内元素内只能放其他行内元素
*注*链接里面不能放链接
3. 行内块元素：img input td
特点：可以一行多个显示，但之间会有空隙；默认宽度是内容宽度；高，行高，内外边距都可以控制
### 元素显示模式的转换
1. 转 块元素：display:block;
2. 转 行内元素：display:inline;
3. 转 行内块元素：display:inline-block;
*注*：转行内块元素后经常会出现缝隙，这是换行符被解析为空格所致。解决办法为清楚回车或者将字号调为0
## css布局技巧
1. 文字垂直居中：line-hieght等于盒子高度，则垂直居中；大于盒子高度，则偏下；小于盒子高度，则偏上。
2. 文字或行内块元素水平居中：text-align:center;
3. 盒子水平居中： margin:0 auto;
4.利用padding实现a链接可点击区域的扩大
## div盒子模型
1. **盒子模型的组成**：border边框、content内容、padding内边框、margin外边框
2. **边框**：border-width:5px; 
border-style: solid| dashed | dotted; 
border-color: pink;
复合写法： border: 1px solid red; (无顺序要求)
只设定一条边框： border-top | bottom | left | right;
将表格中两个单元格的边框合并： border-collapse: collapse;
*注*：边框会增加盒子的宽度和高度。但是在box-sizing: border-box; 下就不会。
3. **盒子内边距**：padding以及padding-left | right | top | bottom
padding: 5px; 上下左右各5px
padding: 5px 10px ; 上下5px,左右10px
padding: 5px 10px 20px ; 上5px, 左右10px, 下20px
padding: 5px 10px 20px 30px; 上5px, 右10px, 下20px, 左30px
*注*：padding也会撑开宽度和高度，但是在box-sizing: border-box; 下就不会。
*注*：如果盒子未指定宽、高，则padding不会撑开盒子
*注*：padding没有auto
4. **盒子外边距**：margin以及maigin-left | right | top | bottom
复合写法和padding一样
5. **清除内外边距**：网页很多元素都带有默认的内外边距，第一步就是要清除自带样式
```css
*{
    padding:0;
    margin:0;
}
```
6. **嵌套崩塌**：
    * 父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值，而子元素的上外边距则不会生效。下外边距也类似。
    * 两个垂直方向上的盒子，第一个盒子的下外边距与第二个盒子的上外边距之间会塌陷最大的边距值，不会同时生效。
    **嵌套崩塌的解决方案**：
* 为父元素定义上边框
* 为父元素定义上内边距
* 为父元素添加overflow: hidden;
7. **圆角边框**：border-radius: length| 50%;
border-radius: 10px 20px 30px 50px ;
border-top（上下）-left（左右）-radius: 10px;
8. **盒子阴影**：
box-shadow: h-shadow(水平位置) v-shadow（垂直位置） blur（模糊距离） spread（模糊半径） color（颜色） inset（将默认外部阴影outer改为内部阴影;
例：box-shadow:10px 10px 5px red;
9. **文字阴影**:
text-shadow:  h-shadow(水平位置) v-shadow（垂直位置） blur（模糊距离）color;

## 列表li的样式
使用`li{ list-style: none;}`去掉`<li>`前面的小圆点
## 传统网页布局的三种方式
1. **普通流**：标签按照默认方式排列，块元素独占一行，从上到下。行内元素从左向右，碰到父元素边缘自动换行。
2. **浮动流**：多个div并列排列
3. **定位**
## 浮动
1. **语法**： float:left | right | none;
2. **浮动特性**：
    * 浮动元素会脱离标准流，且不再保留原来的位置。后面的盒子会跑上来
    * 多个浮动的盒子会在一行内上端对齐排列，若父类元素装不下则会另起一行
    * 任何元素都可以浮动，浮动后具有行内块元素的特征，其宽度由内容决定
3. **清除浮动**：
    * 额外标签法：在浮动元素的末尾加一个空的块状标签，例
    `<div style="clear:both"></div>`
    * 父级添加overflow: hidden | auto | scroll
    * after伪元素法（给父元素添加）
    ```
    .cleaffix: after{
        content:"";
        display:block;
        height:0;
        clear: both;
        visibility:hidden;
    }
    ```
    ```
    .clearfix:before,.clearfix:after{
        content:"";
        display: table;
    }
    .clearfix:after{clear:both;}
    ```
## css属性书写顺序
1. 布局定位属性：display/position / float / clear / visibility / overflow
2. 自身属性：width / height / margin / padding / border / background
3. 文本属性：color / font / text-decoration / text-align / vertical-align / white-space 
4. 其他属性：content / cursor / border-radius / box-shadow / background:linear-gradient
## 定位
1. 定位模式position
    * static静态定位：默认定位方式，即无定位
    * relative相对定位：相对于原来的位置，且不脱标
    * absolute绝对定位：相对于最近一级且有定位的父元素，如果父元素都无定位，则相对于浏览器定位
    *注*：绝对定位会脱标，注意与相对定位区别
    *注*：绝对定位虽然不占有位置，但会压住其内容区域下的a链接，使得a链接无法点击
    * fixed固定定位：以浏览器可视窗口为参照点
    *注*：固定定位也会脱标，相当于特殊的绝对定位
    * stickly粘性定位：当元素与浏览器的top值满足条件是触发，必须设置top值
    
2. 边偏移：top bottom left right 相对于定位父元素边线的距离

3. 定位叠放次序z-index:可取正整数、负整数和0，数越大则越上层。 默认是auto，按照定位的书写顺序排序，后来居上

    *注*：z-index取负值，且此时父级盒子背景非透明，则定位元素会被盒子背景盖住

4. 设置固定定位和绝对定位后，非块状元素也可以设置宽高，块状元素则在无宽高的情况下由内容决定大小，即具有行内块元素的特点。
    *注*：浮动float和flex布局也具有上述特点
    *注*：如果top bottom left right 四个值俱全，则即使没有宽高也会形成一片固定区域

5. 浮动的元素虽然会压住后面的盒子，但是却不会压住标准流的文字，因为浮动的初衷是为了做文字环绕效果，文字会自动环绕在浮动元素周围
## 元素的显示与隐藏属性
1. display: none; 隐藏对象，且不再占有位置
display: block; 转换块级元素，同时显示元素
2. visibility: visible; 元素可视
 visibility: hidden; 元素隐藏，但是继续占有原来的位置
3. overflow：hidden; 溢出隐藏 | scroll;滚动条 | auto;溢出时显示滚动条
4. opacity：0; 元素不可见，但还占有位置
## 私有化前缀
1. Gecko内核，火狐浏览器 -moz-
2. Webkit内核，谷歌内核，safari、谷歌浏览器， -webkit-
3. Trident内核，opera采用，-o-
*注*：可安装css-auto-prefix插件自动添加前缀
## 响应式布局
1. @media监听媒体变化
```
@media only mediaType and (mediafeature) and (mediafeature2)
{css code}
```
```
@media only screen and (min-width: 1200px)
{
    .box{
        background-color: #f00;
    } 宽度大于1200px，盒子红色
}
```
2. 响应式一般分为四个等级：lg 屏幕宽>1200px;md 992px-1200px ;sm 768px-992px; xs <768px

## CSS补充
1. **鼠标样式**：cursor: default默认 | pointer小手 | move移动 | text文本 | not-allowed 禁止
2. 单行文本省略号：
```
white-space: nowrap;(默认normal) //强制一行内显示文本
overflow:hidden; 隐藏溢出文本
text-overflow: ellipsis; 用省略号代替溢出文本
```
3. 多行文本省略号：
```
overflow:hidden;
text-overflow:ellipsis;
display:-webkit-box;
-webkit-line-clamp:2;
-weblit-box-orient:vertical;
```
4. box-sizing:content-box盒子大小为width+padding+border
border-box盒子大小为width，即padding和border不会撑大盒子
5. filter:blur(5);使图片模糊，值越大，越模糊   
6. text-transform:upper-case大写 | lower-case小写
7. width:fit-content;让盒子宽度自动适应内容
8. background-clip：paddingbox;裁切背景，只留下从padding开始渲染的部分
*注*：背景默认从左上角渲染，包括边框border区域
9. 标签的title属性用于鼠标的hover效果
10. 伪元素不是真正的元素，无法被元素选择器选择到
11. HSL颜色：hue色调 ，saturation饱和度， lightness亮度
12. user-select:none;让用户无法选择文字
`hsl(120,65%,75%)`
13. padding颜色和背景色相同；border的颜色默认跟字体颜色相同
14. 给遮罩层设置pointer-events:none，给遮罩层的子盒子pointer-events:auto，就可以实现能够选择遮罩层下面的元素。
15. 选择器前面加::deep实现样式穿透
16. `.nav::-webkit-scrollbar {height: 0px;}`隐藏滚动条
17. `left:unset;`unset可使原有的属性不生效
# JS基础
## 变量
1. 变量是用来保存数据的容器，必须先声明再使用

2. var let const的区别
|特征|var|let|const|
|---|---|---|----|
|作用域|函数作用域|块作用域|块作用域|
|是否允许重复声明|是|否|否|
|是否可以赋值修改|是|是|否|
|是否存在声明提升|是|否|否|
*注*：var 在全局中声明的变量会成为window的属性，而其他两者则不会
### 变量声明规则
1. 只能使用字母、数字、下划线和$
2. 不能以数字开头
3. 严格区分大小写
4. 不能使用var等JS关键字
5. 多个单词使用驼峰命名，backgroundColor
6. 命名语义化
## 数据类型
### 基本数据类型（简单数据类型）
1. 字符串string
2. 数字number
几个特殊数字类型：Infinity, -Infinity, NaN
*注*：计算不出结果是会显示NaN，任何数和NaN计算都会是NaN
*注*：NaN不等于另一个NaN
*注*：利用isNaN()判定是否为NaN
3. 布尔类型boolean
4. undefined类型
5. null类型
### 引用数据类型（复杂数据类型）
1. 数组array
*补充*：数组的克隆
```
arr2=arr1;
arr2=arr1.slice();
arr2=arr1.concat([]);
JSON.parse(JSON.stringify(arr1));
```
上述方法前三种共有的弊端：无法深克隆数组中的值也是引用对象时的数组。JSON方法会丢失函数
2. 对象object
对象的属性名是字符串，不加引号也可以，会隐式转换为字符串
对象.属性名 的使用方式仅限于属性名为非变量或非数字时。如果为变量或者属性名为数字，则需要使用对象[属性名]
*注*：对象中的函数可以省略属性名，直接写函数

3. 函数function
### 简单数据与复杂数据的区别
1. 简单数据存储在栈中，复杂数据存储在堆中
2. 对于简单数据的复制，会在栈中生成一个全新的存储地址，两者互不干扰；而对于复杂数据的复制，会在栈中复制一个引用，本质上在堆中的地址不变，所以对于其中一个数据的修改也会导致另一个数据的改变。
### 数据类型的判别
利用typeof num
*注*：typeof无法准确判断数组和null类型数据。因为逻辑上讲，null值表示一个空对象指针，故typeof null也会输出Object。
1. 准确判断Null
使用===null判断，因为Null的值只有一个，若某个变量全等于null，则一定是Null类型
2. 准确判断Array
使用Array.isArray()
3. 准确判断对象Object
如果既不是Null，也不是Array，那么就是Object
### 数据类型的转换
1. 隐式转换
    * 变量和字符串相加会转换为字符串
    * +str会将str转换为数字类型
    
2. 转字符串
    1. String(a) 隐式转换适用规则
    2. a.toString() 用于数字、Boolean、字符串、对象。对数值调用此方法时，可以传入底数表示以什么进制输出字符串，如10.toString(16)
    3. ""+数字 
    
3. 转数字
    1. Number(a) 隐式转换适用规则
    true转成1
    false, 空字符串，全空格字符串，null,字符串0转为0
    undefined, 非数字字符串转为NaN
    纯数字字符串转为正常数字
    如果是以Ox开头的十六进制字符串则按照16进制转换为10进制的数
    2. +str
    3. parseInt(str)
    从第一个非空格字符串开始转换，只保留字符串开头的数字，自动取整且非四舍五入，对于非字符串会先转字符串再执行。如果以0x或者0开头则按照16进制和8进制转换
    ```
    parseInt("aaa2019")//输出NaN
    parseInt("168.23")//会输出168
    parseInt("11"，16)//会输出17，其中16表示按16进制输出
    ```
    4. parseFloat(str)
    与parseInt类似，不过会保留小数。始终忽略开头的0，且只能用于10进制
    
4. 转Boolean:Boolean(a) 隐式转换适用规则
    非空字符串（包括空格）和非0数字转为true
    null, undefined, 0, NaN, 空字符串转为false

  *注*：可利用!!将任意值转换为它对应的布尔值
## 自增和自减
1. n*=3+5等于n=n*(3+5)
2. n=m++先赋值再自增； n=++m 先自增再赋值
## 比较运算
1. 任何值和NaN比都是false
2. 两个数字字符串进行比较时，不会转换为数字，而是比较相应数位的ASCⅡ编码
3. 相等判断==，存在隐式转换
！=，不等判断
4. 严格相等判断===，会先判断数据类型是否相等，无隐式转换
！==，严格不相等
*注*：null==undefinded为JS规定，无隐式转换。但是对于>,<,<=,>=则会隐式转换
*注*：null>0和null==0都是false， 但是null>=0却为true
## 逻辑运算
1. **逻辑运算符**：与&& 或|| 非！
2. **短路运算**：或运算遇到true就结束；且运算遇到false就结束
`a=a || 2;`
## 条件句
1. 三元运算符`price=num>=20? 5:6;`
*注*：最好是一个数值，而不是赋值语句
2. break与continue的区别
break退出循环；continue仅退出当次循环
3. switch是作严格相等判断
```
switch(a)
{
    case 1: ;break;
    case 2: ;break;
}
```
*注*：切记break不能忘

## 方法
### Math对象方法
1. Math.abs()
2. Math.floor()向下取整； Math.ceil()向上取整
3. Math.max()取最大值； Math.min()取最小值
    *注*：实现"30< x < 50"可以用`Math.min(Math.max(30,x),50)`
4. Math.pow(x,y)求x的y次方
5. Math.sqrt()开方
6. Math.round()四舍五入到整数
    *注*：整数四舍五入；负数五舍六入
    *注*：由于JS表示小数不精确，所以实际过程中会出现一些误差
7. Math.sin(Math.PI/6)求Π/6的sin值，必须用弧度制
7. Math.random()取[0, 1)之间的随机数
*注*：若想取其他区间需要相应变化，如[0,100]需要`Math.floor(Math.random()*101)`
*注*：若想使生成的随机数至少保持10的间隔，需要使用最小公差随机公式`Math.floor(Math.random()*101/10)*10`，但是此方法实际上损失了随机范围
*注*：巧取随机16进制颜色`parseInt(Math.random()*0xffffff).toString(16)`
### Date对象方法
1. new Date()构建保存当前时间（这句代码运行时）的对象
new Date("2020-01-01 9：13：00")构建保存过去时间的对象
2. Date.now()获取当前时间（代码运行时）的时间戳
nowDate.getTime()获取变量nowDate的时间戳
*注*：时间戳为距离1970年1月1日0：00：00的毫秒数
3. nowDate.getFullYear()获取年 nowDate.getMonth()获取月（是从0开始算的）
nowDate.getDate()获取日 nowDate.getHours()获取时
nowDate.getMinutes()获取分 nowDate.getSeconds()获取秒
nowDate.getMilliseconds()获取毫秒
### 数组方法
1. arr.push(元素1，元素2) 在数组末端添加一个元素，返回值是新数组的长度
2. arr.unshift() 在数组前面添加一个元素，返回值是新数组的长度
3. arr.pop()删除数组最后一个元素，返回值是删除元素
4. arr.shift()删除数组最前面的一个元素，同时后面元素前移,返回值是删除元素
5. arr1.concat(arr2,arr3.....)可以接受多个数组或者分散的元素，但是不会改变原数组
6. arr.join("&")将数组用&符号（可换其他符号）连接成字符串，也不会改变原数组
7. arr.splice(x,y,"张三")将原数组从索引x开始删除y个元素，并用"张三"替换
返回值是删除元素组成的新数组.若y未指定则删除从x开始的所有元素。
*注*：arr.splice(i,0,",")是在索引i的位置的前面补逗号
8. arr.slice(i,j)截取数组索引i到j-1的部分，且不改变原数组。若只写一个参数，则默认后面全部截取；不写参数则克隆数组；如果是负数，则从后面开始截取
9. arr.includes("c",3) 从第3的位置开始搜索字符"c"，如果找到返回true，否则返回false
10. arr.indexOf("c") 获取字符"c"在数组中的索引，没找到则返回-1
arr.lastIndexOf("c") 倒着获取
11. Array.isArray(arr)判断arr是否为数组，返回true或者false
12. arr.sort()不带参数是按照数组元素的unicode编码排序
`arr.sort(function(a,b){return b-a;})`
b-a是大到小排序，a-b是小到大
13. arr.reduce(callback(prev,next[,index,array]),初始值) 对数组中的每一个值执行callback回调函数
*注*：若给定初始值，则prev取初始值，next取数组第一项；否则prev取数组第一项，next取数组第二项
```
//下面是删除对象中的color属性的实例
const car = {
  color: 'blue',
  brand: 'Ford'
}
const prop = 'color'
const newCar = Object.keys(car).reduce((object, key) => {
  if (key !== prop) {
    object[key] = car[key]
  }
  return object
}, {})
```
14. arr.forEach(function(item,index,origin){},this) 遍历数组，挨个执行function，其中item为当前值，index为当前值的索引，origin为该数组。第二个参数this表示this指向
15. arr.map(function(item,index,origin){return item+1}) 与forEach类似，不过会返回一个由return出去的值构成的新数组（原数组不变）
16. arr.filter(function(item,index,origin){item>2;}) 进行过滤，筛选出符合条件的元素，组成一个新的数组返回，不会改变原数组。
17. arr.find(function(item,index,origin){item>2;}) 找到符合条件的元素，返回该元素，若没找到则返回undefined。
18. arr.findIndex(function(item,index,origin){item>2;}) 找到符合条件的元素，返回该元素的下标，若没找到则返回-1。
19. arr.every与arr.some
every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。
some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。
```
var arr = [ 1, 2, 3, 4, 5, 6 ]; 
console.log( arr.some( function( item, index, array ){ 
    return item > 3; 
}));   // true 
console.log( arr.every( function( item, index, array ){ 
    return item > 3; 
}));  // false
```
20. Array.from(类数组对象,回调函数) 用于将类数组对象转为真正的数组(类数组对象比如arguments和HTMLCollection)
```
var obj1={
        0:'html',
        1:'css',
        2:'js',
        3:'vue',
        length:4 //注意
    }        
  console.log(Array.from(obj1,i => i + 'a')); 
```
21. Array.of() 将一组值转换为数组。
`const arr5 = Array.of(3,5); //arr5=[3,5]`
22. `...arr`将数组展开为逗号隔开参数序列，常用于合并两数组
```
var arr = [1,2],arrs = [3,4];
var newArr = [...arr,...arrs];
console.log(newArr) // [1,2,3,4]
```
23. arr.reverse()将数组倒转，返回倒转后的数组，返回的数组指向原数组，即会改变数组
### 字符串方法
部分方法与数组相同，但是字符串无法随意删除或者添加字符
1. str.split("=") 以=将一个字符串分割为数组，可定义第2个参数决定返回数组的长度
2. str.indexOf("w")和str.lastIndexOf("w")，没找到则返回-1
3. str.slice(2,6)截取字符串,不传参默认全部截取。
str.substr(2,6) 也是截取字符串，但是这里的6不是结束索引，而是截取个数
4. str.concat("and you")连接字符串
5. str.toUpperCase()转大写；str.toLowerCase()转小写
*注*：以上这些方法都不会改变原字符串
6. str.replace(regexp/substr,replacement)方法：将第一个匹配到substr的字段替换为replacement字段，并返回替换后的字符串，也可配合正则使用，replacement也可是函数
7. str.repeat(n) 将字符串重复n次
`var str="你好";console.log(str.repeat(3)) //你好你好你好`
8. str.padStart(targetLength,padString 可选) 将str用padString补齐到和targetLength的长度，在开头补
str.padEnd(targetLength,padString 可选) 在结尾补
9. str.trim() 去除字符串首尾的空格、制表符、换行符等
10. str.includes("hello",1) 从1的位置开始查找"hello"字符串片段，如果找到就返回true，否则false
### 其他方法
1. ele.closest()匹配特定选择器且离当前元素最近的父类元素，也可以是当前元素本身，没有则返回null
2. 函数.apply()和函数.call()
两者作用相同，区别在于apply方法的第二参数是数组，而call的第二个参数（及其后面的所有其他参数）是以逗号分隔，分开写的。且apply会默认将数组转换为参数列表
```
 function Person(name,age)  
    {  
        this.name=name;  
        this.age=age;  
    }  
    /*定义一个学生类*/  
    function Student(name,age,grade)  
    {  
        Person.apply(this,arguments);  //或者Person.call(this,name,age);
        this.grade=grade;  
    }  
    //创建一个学生类  
    var student=new Student("zhangsan",21,"一年级"); //student为name:zhangsan age:21  grade:一年级  
```
通常利用apply实现函数呼叫转移：
```
function sum(...args){
    let count=0;
    args.forEach(function(item){
        count+=item;
    })
    return count;
}
function sum2x(...args){
    return sum.apply(null,args)*2;
}
```
*注*：apply的妙用：`Math.max.apply(null,array)`取数组最大项;
`Array.prototype.push.apply(arr1,arr2)`合并两数组
*注*：call的妙用：
```
//利用filter将字符串转换为无重复字母的数组
var strArr = [].filter.call(str, function (current, index, arr) { return arr.indexOf(current) == index; });
```
3. `console.clear()`清空输出
4. URL.createObjectURL()与URL.revokeObjectURL()生成文件的路径
`let imgUrl = URL.createObjectURL(file);URL.revokeObjectURL(imgUrl);`
*注*：revokeObjectURL中的参数不一定要写imgUrl，只要是与imgUrl相等的路径字符串即可
5. console.time("名字")计算程式运行时间
```
console.time("jc");
jc(120);
console.timeEnd("jc");
```
## 对象
### 对象的属性描述符
我们使用对象描述符来描述对象属性的特性，分为两种：数据属性和访问器属性
1. 数据属性(前三个属性默认为true，value默认为undefined)
    1. [[Configurable]] 设置能否通过 delete 删除属性，或者能否修改其他三个数据属性,。*注*：即使Configurable为false，还是可以将writable由true改为flase
    2. [[Enumerable]] ：表示能否通过 for-in 循环遍历。
    *注*：控制台展开的对象中颜色变淡的属性表示不可遍历的属性
    3. [[Writable]] ：表示能否修改属性的值。
    4. [[Value]] ：包含这个属性的数据值。
*补充*：通过Object.defineProperty()或者Object.defineProperties()设置对象某个属性的属性描述符
```
Object.defineProperty(person, "name", {
    enumerable: true, 
   value:'libai', // name对应的值
});
//或者一下设置多个属性的属性描述符
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
});
```
2. 访问器属性的描述符
对于访问器属性，没有 value 和 writable，但是有 get 和 set 函数。
*注*；利用defineProperties设置属性描述符时value、writable和get、set不能共存
所以访问器描述符有：
* get —— 一个没有参数的函数，在读取属性时工作，
* set —— 带有一个参数的函数，当属性被设置时调用，
* enumerable —— 与数据属性相同，
* configurable —— 与数据属性相同。
```
        let user = {
            name: "John",
            surname: "Smith"
        };
        Object.defineProperty(user, 'fullName', {
            get() {
                return `${this.name} ${this.surname}`;
            },
            set(value) {
                [this.name, this.surname] = value.split(" "); //学习一下这种赋值方法
            }
        });
        alert(user.fullName); // John Smith
        user.fullName = "libai dufu";
        console.log(user); //{name:"libai",surname:"dufu"}
```
*补充*：使用`Object.getOwnPropertyDescriptor(obj, "name")`来获取obj中name属性的属性描述符。
*补充*：使用`Object.getOwnPropertyDescriptors(obj)`来获取obj中所有的属性描述符。
### 对象的方法
1. Object.keys()获取对象中可遍历的所有属性名；Object.getOwnPropertyNames(obj)获取所有属性（不管是否可遍历）
*注*：不可遍历的属性主要是指defineProperty设置的enumerable为false的属性
2. Object.values()获取对象中的所有属性值
*注*：巧用此方法可实现数组的克隆，Object.values(arr)
3. Object.assign(target,source1,source2....)
 将一个或多个源对象的所有可枚举属性的值复制到目标对象。它将返回目标对象。
 *注*：该方法会改变原target对象
 *注*：同名属性遵照后者覆盖前者的原则。可用于函数中赋予一个对象默认参数。
4. "key" in object检查某属性在对象中是否存在
5. delete object.attribute 删除对象的属性。该方法有一个true|false返回值，表示删除成功与否。
6. 限制访问对象的方法
    * Object.preventExtensions(obj)禁止向对象添加属性。
    * Object.seal(obj)禁止添加/删除属性，为所有现有的属性设置 configurable: false。
    * Object.freeze(obj)禁止添加/删除/更改属性，为所有现有属性设置 configurable: false, writable: false。
    * Object.isExtensible(obj)如果添加属性被禁止，则返回 false，否则返回 true。
    * Object.isSealed(obj)如果禁止添加/删除属性，则返回 true，并且所有现有属性都具有 configurable: false。
    * Object.isFrozen(obj)
    如果禁止添加/删除/更改属性，并且所有当前属性都是 configurable: false, writable: false，则返回 true。
7. Object.create(Person.prototype)创造一个以括号内对象为原型的对象
`let temp2 = Object.create(Person.prototype)` 
*补充*：可利用此方法创建一个没有原型的对象，Object.create(null)
### 对象的克隆
1. 对象克隆两种方法：`newObj=Object.assign({},obj)`和`newObj=JSON.parse(JSON.stringify(obj))` 。前者的弊端在于若属性值也为引用类型时只能浅克隆，后者的弊端在于会丢失函数和undefined。浅克隆时obj2.hobby===obj1.hobby为true，因为两个对象的hobby为引用类型时指向同一堆中的地址。
*注*：函数特殊，因为对于函数的修改都是整体修改，相当于重新指向一个堆的地址，对浅克隆对象的函数的修改不会影响原对象中的函数。
2. 既克隆原型又克隆自身属性
```
// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};
// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);
// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
//写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。
```
## 函数
1. 对于双层嵌套函数，内层函数的return是不会返回到最外层去的
2. 箭头函数的this指向父级函数的调用者，且不受bind和call的影响。且箭头函数没有自己的arguments,只有外部函数的arguments。但可以使用rest代替arguments
3. 函数声明与函数表达式创建函数的最大区别在于：前者具有函数声明提升能力，后者没有。
4. 形参个数 > 实参个数 多余的形参值是 undefined；
形参个数 < 实参个数 多余的实参可以在 arguemnts 里找到
5. arguments 在非严格模式下，arguments 里的元素和函数参数都是指向同一个值的引用，对arguments 的修改，会直接影响函数参数。 arguments.callee 是对当前函数的引用（面临淘汰）;严格模式下 arguments 是函数参数的副本，对 arguments 的修改不会影响函数参数，并且 arguments 不能重新被赋值。
6. 形参的变化反映在arguments中，类似镜子内外的映射,在函数中对形参再赋值，相应的arguments值也会改变
7. 原始值与引用值作为实参的区别：
    * 简单类型值作为参数，函数内部的变化不会影响到传入的变量
    * 引用类型值作为参数，函数内部的变化会影响到传入的变量

8. 立即执行函数
```
// 1. 函数表达式的立即执行
var fn = function (){
  console.log("函数表达式的立即执行");
}()
// 2. 声明/匿名函数的立即执行
// 为保证代码运行安全，一般在第一个小括号前加 分号
;(function(形参){
    console.log("传入的参数", 形参)
}(实参));
;(function fn(){
  console.log("立即执行");
})();
```
*注*：为什么函数表达式的立即执行只需要在函数后面加一个小括号就可以了，而声明/匿名函数的立即执行却需要用括号把整体括起来呢？本质上是函数表达式的赋值会默认先将"="右边的东西计算出来再赋值，所以右边的函数得到了立即执行，同理下面的函数也可以立即执行
```
+function (){
  console.log("函数表达式的立即执行");
}()
```
9. 简单类型值作为形参时，在函数内对形参的修改不会影响函数外
```
var a = 1;
        function fn(a) {
            a = 2;
        }
        fn(a);
        console.log(a);  //a依然为1
```
*注*：若是引用类型值作为形参，且在函数类内没有对该形参进行重新赋值，则对形参某个属性值的修改会影响外界的实参
```
var obj={};
function fn(obj) {
            obj = {name:"libai"}; //重新赋值，相当于重新声明了一个对象，不会改变原实参
            obj.name="libai"; //会改变原实参
        }
        fn(obj);
```
### 函数的属性
1. fn.name 返回函数的名称
```
// 下面这种情景要注意，count仅作为函数名存在，不能在window上调用.调用应该用fn(),而不是count()
但可以在count函数内部调用count，原因可能是count没有赋值的声明提升，所以window上调用是undefined
var fn = function count(){}
console.log(fn.name);// count
```
2. fn.length 返回函数的形参个数（剩余参数不计入形参个数）
3. fn.prototype 返回函数的原型对象

### 函数的方法
1. 函数.apply()和函数.call()
两者作用相同，区别在于apply方法的第二参数是数组，而call的第二个参数（及其后面的所有其他参数）是以逗号分隔，分开写的。且apply会默认将数组转换为参数列表
```
 function Person(name,age)  
    {  
        this.name=name;  
        this.age=age;  
    }  
    /*定义一个学生类*/  
    function Student(name,age,grade)  
    {  
        Person.apply(this,arguments);  //或者Person.call(this,name,age);
        this.grade=grade;  
    }  
    //创建一个学生类  
    var student=new Student("zhangsan",21,"一年级"); //student为name:zhangsan age:21  grade:一年级  
```
*补充*：apply的妙用：`Math.max.apply(null,array)`取数组最大项;
`Array.prototype.push.apply(arr1,arr2)`合并两数组
*补充*：apply 最重要的用途之一是将调用传递给另一个函数，如下所示：
```
let wrapper = function() {
  return anotherFunction.apply(this, arguments);
};
```
这叫做 呼叫转移。wrapper 传递它获得的所有内容：上下文 this 和 anotherFunction 的参数并返回其结果。
2. 函数.bind(this,[可选参数]) 可选参数会固定在调用bind的函数上，利用这一点可制作一部分参数固定的偏函数。示例：
```
let user = { name: "libai" };
        function saytime(time, doing) {
            console.log(`${this.name}在${time}${doing}`);
        }
        let saytimefixed = saytime.bind(user, "6:00 pm");
        saytimefixed("写诗"); //libai在6:00 pm写诗
        saytimefixed("作画"); //libai在6:00 pm作画
        saytimefixed("唱歌"); //libai在6:00 pm唱歌
        //time这个参数已经被固定为"6:00 pm"了
```
*注*：apply、bind、call传递的作为this的参数如果不是对象或者无法转换为对象，那么默认以window作为函数的this。此外数字、字符串、布尔值是有对象类型的，若用它们作为参数会被转为对象形式
`sayName.call(123)`此处不会以window作为this，而是以{123}作为this。
### 高级函数
1. 函数的柯里化
所谓柯里化就是把fn(a,b,c)改成fn(a)(b,c)或者fn(a)(b)(c)
```
function sum(a, b, c, d) {
            console.log(a + b + c + d);
        }
        function curry(fn) {
            return function curried(...args) {
                if (args.length >= fn.length) {
                    // sum.apply(null, args);
                    (sum.bind(null, ...args))();  //apply和bind任选一种都行
                }
                else {
                    return function (...args1) {
                        // return curried.apply(null, args.concat(args1));
                        return (curried.bind(null, ...args.concat(args1)))();
                    }
                }
            }
        }
        let sumcurried = curry(sum);
        sumcurried(1, 2, 3, 4); //10
        sumcurried(1, 2)(3)(4); //10
        sumcurried(1)(2)(3)(4); //10
```
2. 组合函数
```
function addOne(x) {
            return x + 1;
        }
        function addTwo(x) {
            return x + 2;
        }
        function addThree(x) {
            return x + 3;
        }
        function mixfn(x, ...args) {
            return args.reduce((prev, nex) => { return nex(prev); }, x);
        }
        console.log(mixfn(1, addOne, addTwo, addThree));
```
### 函数的执行过程
1. 创建 EC 阶段（时间节点：函数被调用，但未执行任何内部代码时）
这时候的 AO 包括：
* 函数的所有形参：由名称和对应值组成的一个变量对象的属性被创建，若没有实参，属性值设为 undefined
* 函数声明：由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建，如果变量对象已经存在相同名称的属性，则完全替换这个属性
* 变量声明：由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
2. 执行阶段：在当前上下文上运行函数代码，并随着代码一行行执行指派变量的值（AO）
### 函数的原型
1. prototype
无论什么时候，只要创建了一个新函数，js 就会根据一组特性的规则为该函数创建一个 prototype （原型）属性，这个属性是一个指针，指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。而且，只有函数对象才拥有 prototype （原型）属性。
2. `__proto__`(两个下划线)
当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。
3. `prototype、__proto__、constructor`三者间的关系：构造函数（或普通函数）的prototype指向该函数的原型对象，由构造函数new出来的实例的`__proto__`也指向函数的原型对象，而函数的原型对象的constructor指向原构造函数。
4. 原型对象的所有属性都会被所有实例（这些实例都指向这一个原型）所共享
```
function User(name) {
            this.name = name;
        }
        console.log(User.prototype.constructor);
        let libai = new User("libai");
        console.log(libai); // User{name:"libai"}
        User.prototype.age = 14;
        console.log(libai.age);//14
```
*注*：实例只能使用这些属性，却不能更改原型对象的属性。 如下：
```
 function User(name) {
            this.name = name;
        }
        let libai = new User("libai");
        libai.age = 14;
        console.log(User.prototype.age); 
        //undefined，原因是age被当成是libai这个对象的属性名被添加了
```
*注*：User.prototype的指向改变，则新new出来的的实例的__proto__也会改变。如下：
```
function User(name) {
            this.name = name;
        }
        let libai = new User("libai");
        console.log(libai.__proto__);
        User.prototype = { age: 100 };
        let dufu = new User("dufu");
        console.log(dufu.__proto__); //{age:100}
*注*：即使原型具有动态性，在原型上添加的属性和方法能够立即反映在实例中，但若重写构造函数的原型，情况就会大不一样
        console.log(libai.age); //undefined
//因为此时libai只指向最初的原型，而不指向构造函数User，即使User重构后的原型中有age，但此时libai指向的依然是最初的原型，所以无法读取age的值
```

```
function User(name) {
            this.name = name;
        }
let person=new User("libai");

```
5. *面试*：`Function.__proto__ === Function.prototype` // true Function类作为最顶层的类，原型属性指向的是自己的原型对象,这个原型对象是`ƒ () { [native code] }`
```
function fn() { }
        console.log(fn.__proto__); //ƒ () { [native code] }
        console.log(fn.prototype); //{constructor: ƒ}
```
6. 使用new创建对象时的四部：1.创建对象；2设置对象原型；3绑定this属性；4.返回对象
#### 函数原型的方法
1. `实例.hasOwnProperty(属性名)` 方法可以检测一个属性是存在于实例中，还是存在于原型中。只在给定属性存在于对象实例中时，才会返回 true 。
2. `obj.isPrototypeOf(实例)` 判断一个对象是否是某个实例的原型对象
3. `Object.getPrototypeOf(实例)` 获取一个实例的原型对象
`Object.setPrototypeOf(实例,obj)` 设置一个实例的原型对象
*注*：这两个都是老方法了，现在多直接用`obj.__proto__`
4. `实例 instanceof 构造函数`判断该实例是否是该构造函数所构造的实例
```
let obj={};
console.log(obj instanceof Object) //true
console.log([] instanceof Array) //true
console.log([] instanceof Object) //true
```
5. *面试*：借助Object.prototype.toString()检验数据类型
```
Object.prototype.toString.call(123);      // "[object Number]"
Object.prototype.toString.call('dsf')     // "[object String]"
Object.prototype.toString.call({})        // "[object Object]"
Object.prototype.toString.call([])        // "[object Array]"
Object.prototype.toString.call(true)      // "[object Boolean]"
Object.prototype.toString.call(undefined)// "[object Undefined]"
Object.prototype.toString.call(null)    // "[object Null]"
Object.prototype.toString.call(NaN)        // "[object Number]"
Object.prototype.toString.call(Infinity)// "[object Number]"
Object.prototype.toString.call(new Date())// "[object Date]"
Object.prototype.toString.call(Math)     // "[object Math]"
Object.prototype.toString.call(JSON)    // "[object JSON]"
```
#### 原型链
原型呈现递进关系，由此形成的链式结构称为原型链。它提供了对象属性的查找方向：由当前对象沿着原型链向上追溯，返回最近查到的属性值，原型链的终点是null
```
let anotherobj = { age: 14, toString() { console.log("ok"); } };
        let obj = {};
        obj.__proto__ = anotherobj;
        console.log(obj.__proto__.__proto__); //Object
        console.log(obj.toString); //如果anotherobj中有toString，则优先输出，否则输出Object上的toString
        console.log(obj.age); //14
```
#### 继承
1. 借助原型链继承
```
function Person(){
    this.name = '李白'
    this.hobbies = ['吟诗','旅游']
}
Person.prototype.sayName = function(){
    console.log(this.name)
}
function Student(){
    this.age = "24"
}
let student = new Student();
student.__proto__=new Person();//这样student便能访问Person的方法
```
*注*：缺点是Person上的私人属性全部作为Student原型对象的属性被共享，当Student构造的实例修改hobbies时，Person中的hobbies也会修改（因为数组是引用类型值）
2. 借助构造函数继承
```
function Person() {
            this.name = '李白'
            this.hobbies = ['吟诗', '旅游']
        }
        Person.prototype.sayName = function () {
            console.log(this.name)
        }
        function Student() {
            Person.call(this); //相当于在student上重新调用Person重新生成hobbies，避免了上一种方法的弊端
            this.age = "24";
        }
         Student.prototype = new Person();
        let student = new Student();
        console.log(student.sayName);
```
*注*：优点在于借助.call避免第一种方法的缺点，以及.call(this,参数)中可以传参数。
*注*：缺点在于student中会生成一遍name和hobbies属性，student的原型（Person构造的实例）也会生成一边name和hobbies属性，重复了
3. 寄生式组合继承（完美解决了上面两种的方法的弊端）
```
function Person() {
            this.name = '李白'
            this.hobbies = ['吟诗', '旅游']
        }
        Person.prototype.sayName = function () {
            console.log(this.name)
        }
        function Student() {
            Person.call(this);
            this.age = "24";
        }
        Student.prototype = { __proto__: Person.prototype };//这一步与上一种方法不同
        //或者使用Student.prototype=Object.create(Person.prototype)
        let student = new Student();
        console.log(student.sayName);
```
### 作用域
1. 变量查找规则：先在自身作用域内查找，如果找不到再向上一级作用域查找，如果全局变量中都找不到，就会报错undefined
2. 执行JS代码之前，会有一个预解析阶段，将所有有用的var声明提升到当前作用域顶部，但不会同时提升赋值语句
*注*：function声明的具名函数也会提升，但匿名函数不会提升。此外函数表达式仅提升声明，不会赋值
*注*：在函数中的var会提升到当前函数作用域的顶部
*注*：函数声明提升优于变量声明提升。
3. 不带var的变量声明默认为全局变量，但严格模式下会报错
4. JS函数使用词法作用域，即静态作用域，函数在声明时确定它的作用域范围
### 闭包
1. 闭包函数：指有权访问另一个函数作用域变量的函数，这样一种现象称为闭包。
```
function fn(){
    let a=1;
    function gn(){
        console.log(a);
    }
    return gn;
}
let gn=fn(); //这样gn函数就能访问到fn里面的a
```
## ES6
### 扩展运算符
1. 只会展开对象自身的可遍历属性
```
let a={name:"libai",hobby:"drink"}
let obj={...a}
//等同于
let obj=Object.assign({},a);
```
2. 扩展运算符可以用于合并两个对象
```
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
//如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。
let obj = { ...a, x: 1, y: 2 };
// 等同于
let obj = Object.assign({}, a, { x: 1, y: 2 });
```
3. 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。
```
const obj = {
  ...(x > 1 ? {a: 1} : {}),
  b: 2,
};
```
4. 执行扩展运算符时会触发get
### 解构赋值
1. 基本用法
```
//1. 按照对应位置匹配(对象是按照属性名匹配)
let [x, , y] = [1, 2, 3];
x // 1 y // 3
//2. 解构失败则赋值为undefined
//3. 允许指定默认值
let [x, y = 'b'] = ['a']; // x='a', y='b'
//注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
//4.对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。
// 例一
let { log, sin, cos } = Math;

// 例二
const { log } = console;
log('hello') // hello
//对象的解构赋值可以取到继承的属性
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);
const { foo } = obj1;
foo // "bar"
//5.已经声明的变量的解构赋值。正常解构赋值必须是仅有的一次声明变量。但可以借助括号作弊
let x;
({x} = {x: 1});
//6.函数参数的解构赋值
function move({x , y }) {
  return [x, y];
}
move({x:1,y:2})  //[1,2]
//也可以在解构赋值时指定默认值
function move({x = 0, y = 0} = {}) {
  return [x, y];
}
move({x: 3}); // [3, 0]
//注意与下面代码区分，很绕
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
move({x: 3}); // [3, undefined]
move(); // [0, 0]
//上述不是带默认值的解构赋值，而是为函数参数指定一个默认值。如果函数传参，则使用传入的参数与{x,y}解构赋值匹配，否则就使用{x:0,y:0}与{x,y}解构匹配
```
2. 解构赋值的高阶用法
```
function f() {
  console.log('aaa');
}

let [x = f()] = [1];
//等同于
let x;
if ([1][0] === undefined) {
  x = f();
} else {
  x = [1][0];
}
```
3. 解构赋值时避免加括号，易报错
```
// 全部报错
let [(a)] = [1];
function f([(z)]) { return z; }
({ p: a }) = { p: 42 };
([a]) = [5];
```
# JS进阶
## DOM
### 节点操作
1. 获取节点
    * 老式方法：document.getElementById("") document.getElementsByTagName("")
    document.getElemenstBy* document.getElementsByClassName("")
    *注*：注意除了ById是Element，其他都是Elements
    *注*：；老式方法获取的是 HTMLCollection 动态节点数组，会随着页面内容的改变而改变
    * 新方法：querySelectorAll(".div") querySelector(".div")
    *注*：querySelector前面的节点不一定是document，可以是任何一个dom节点
    *注*：querySelectorAll(".div")获取的是多个元素的伪数组，可以用forEach方法遍历
    *注*：新方法获取的是NodeList ，是静态节点数组，获取之后页面上标签的改变不会影响数组内容
    *注*：jQ对象也是静态节点数组，获取之后页面上标签的改变不会影响数组内容
2. 关系节点(无括号)
    * 父节点parentNode
    * 兄弟节点：nextSibling nextElementSibling
    previousSibling previousElementSibling
    * 子节点：firstChild firstElementChild
    lastChild lastElementChild
    * 所有子节点：childNodes（所有节点） children（所有的元素节点）
3. 节点增删改查
    * 创造节点 document.creatElement("")
    * 插入父节点中：
        * 父节点.appendChild(新节点) 插入父节点最后一个子节点后面
        *注*：如果新节点已经存在，则会从原来的位置删除，插入到新的位置
        * 父节点.append(新节点)和上面一样
        * 父节点.prepend(新节点)插入父节点第一个子节点之前
        *注*：重复调用append十分浪费性能，多是采用字符串拼接好后再一次性插入
    * 从父节点删除：
        * 父节点.removeChild(子节点)
    * 克隆节点：
    要复制的节点.cloneNode(); //括号里不带参数和带参数false，效果是一样的。只复制节点本身
    要复制的节点.cloneNode(true);既复制节点本身，也复制其所有的子节点。
    * 其他补充方法：
        * el.before()插入到el元素之前
        * el.after()插入到el元素之后
        * el.remove()移除el元素
        * el.replaceWith(新节点)当前el元素替换为另外一个元素
        * el.innerHTML="<span></span>"
        * el.innerAdjacentHTML("afterEnd","<span></span>")
        *注*：第一个参数四种取值：beforeBegin | afterBegin | beforeEnd | afterEnd
4. 节点属性操作：
    * 节点.attribute 读取/设置的是标签属性
    * 节点.getAttribute("") 
    节点.setAttribute("属性名"，"属性值")
    节点.removeAttribute("")
    *注*：这三种方法操作的是DOM标签的属性；而之前的点语法（div.className)操作的是DOM标签的属性
    *注*：自定义属性data-info=""获取时要使用dataset[info]或者dataset.ifno
5. 节点内容操作：
节点.value="" 节点.innerHTML="" 节点.innerText=""
*注*：innerHTML和innerText的区别在于前者会把内容当成标签来解析
6. 节点类型nodeType，属性值为数字
1 表示元素节点 2 表示属性节点 3 表示文本节点 8 表示注释节点 9 表示文档节点(就一个 document)
7. nodeName 节点名称 属性值为字符串
    * 元素节点的名称为大写的标签名
    * 属性节点的名称为属性名
    * 文本节点的名称为 #text
    * 注释节点的名称为 #comment
    * 文档节点的名称为 #document
8. nodeValue 节点值
    * 元素节点没有节点值 null
    * 属性节点的节点值就是属性值
    * 文本节点的节点值是文本内容
    * 注释节点的节点值是注释内容
    * 文档节点没有节点值 null
9. 节点1.contains(节点2)判断节点1中是否包含节点2，返回boolean
### 样式操作
1. 获取样式
    * 获取行内样式 ele.style.属性名
    * 获取计算样式 getComputedStyle(ele,伪元素（可选）)
2. 修改样式
    * ele.style.属性名="" 这样做相当于添加行内样式
    *注*：样式太多时，可使用ele.style.cssText=""
    * ele.classList.add/remove("类名") 通过添加类名间接修改样式
    * ele.classList.toggle("类名") 有则移除，没有则加
    * ele.classList.contains("类名") 判断有无该类名，返回true或false
    *注*：当ele为节点数组，且索引为负数时调用上述方法会报错，但$(ele)[-1]却不会报错
### 事件机制
1. 事件：onclick鼠标点击  oncontextmenu右键点击 onmouseover鼠标移入(onmouseenter) 
onmouseout 鼠标移除(onmouseleave)
onmousedown鼠标按下 onmouseup鼠标释放 onmousemove鼠标移动
onchange改变域的内容时 onfocus聚焦时 onblur失去焦点
onkeydown键盘按下 onkeyup键盘松开 onload页面加载完毕
*注*：mouseover和mouseenter的区别：1.鼠标进入该元素或进入该元素的子元素或从该元素的子元素出来都算作触发mouseover，而mouseenter只有鼠标从元素外面进入元素才会触发，且子元素无法触达；2.mouseover可以冒泡，而mouseenter无法冒泡，这也是产生第一点差异的原因。详情点击https://qianlongo.github.io/zepto-analysis/example/event/mouseEnter-mouseOver.html
*注*：若当前元素上方有定位层级高的其他兄弟元素，则鼠标从该兄弟元素移入当前元素也会触发mouseenter
2. 事件绑定
    1. 行内绑定`<div onclick=""></div>`
    *注*：行内绑定事件的this指向window
    2. 属性绑定ele.onclick=function(){};
    *注*每个dom只能绑定一个事件
    *注*以上两种绑定方式不太一样。onclick绑定具名函数时要带上括号，而属性绑定具名函数不需要带，如果带上括号就相当于把函数运行的结果绑定给该dom对象。
    3. 事件监听ele.addEventListener("click",函数，capture(可选))
    监听移除ele.removeEventListener("click",函数)
3. 补充事件：
    1. 图片加载失败事件imgEle.onerror
    2. window.onload： 页面所有内容加载完毕后触发改事件
    3. window.onunload： 用户退出页面触发该事件
    4. widnow.onresize：当页面窗口大小发生变化的时候会触发该事件
### 定时器
1. setTimeout(函数，延迟时间,函数的参数)
2. setInterval(函数，间隔时间)
3. clearTimeout() clearInterval()
*注*：定时器中的this指向window，可借助函数.bind(this)解决该问题

### Offset家族
1. offsetWidth和offsetHeight返回元素占据页面的实际宽高，包括内边距，边框，滚动条
2. offsetParent返回距离当前元素最近的带有定位的父级元素
*注*：如果当前元素为fixed定位，那么返回值为null
3. offsetLeft和offsetTop返回它与offsetParent边框的上左边距
*注*：如果offsetParent是body，那么body的边框宽度也会计算在内
*注*：上述所有数值都是只读的整数
### Scroll家族
1. scrollWidth和scrollHeight返回元素内容大小，包括溢出，即自身宽高+padding
*注*：属性只读且为整数
*注*：对于行内元素，该值为0
*注*：对于溢出内容，计算上左边距，但若设置overflow，则还计算下内边距
2. scrollTop和scrollLeft元素已卷入的头部和左边部分
*注*：属性可读写，不一定为整数
3. 获取页面卷入上左边距
    * 对于有doctype声明的文档，使用document.documentElement.scrollTop/Left
    * 若没有doctype声明，使用document.body.scrollTop/Left
    * 万能方法（IE9以上）：window.pageYOffset/pageXOffset
4. 监听滚动事件：ele.onscroll或者ele.onwheel
5. window滚动的方法：
    * window.scroll(x,y)和window.scrollTo(x,y)，滚动到
    * window.scrollBy(-x,-y)由当前位置滚动多少
    * ele.scrollIntoView(boolean)让元素贴顶和贴底
6. 网页顺滑滚动
    * 添加css属性`html{scroll-behavior:smooth}`
    *  window.scroll方法传对象参数
    ```
    window.scroll(
        {
            top:2000,
            left:1000,
            behavior:"smooth"
        }
    )
    ```
    window.scrollBy也类似
### Client家族
1. clientWidth和clientHeight返回元素可视区域的宽高，不包括溢出和滚动条，计算内边距
2. clientTop和clientLeft返回元素上左边框的宽度
3. 获取页面可视区域宽高
    *  document.documentElement.clientWidth/clientHeight 不包括浏览器滚动条的宽度
    * window.innerWidth/innerHeight包括浏览器滚动条的宽度
4. 浏览器窗口宽高（包括侧边栏等在内）
    window.outerWidth/outerHeight
5. 屏幕的宽高window.screen.width/height
    *注*：受屏幕缩放比例影响，IE才返回真实的屏幕宽高
6. ele.getBoundingClientReact()返回元素的大小及其相对于视口的位置，包括width,height,top,left,right,bottom
*注*：其中width和height相当于offsetWidth和offsetHeight； right指右边界与窗口最左边的距离，top指下边界与窗口最上边的距离
### Event
1. 常见事件属性：
    * event.type 例如click等
    * event.target 触发事件的元素
    * event.currentTarget 绑定事件的元素
    * event.button 0表示左键；1表示滚轮；2表示右键
    * event.which 1表示左键；2表示滚轮；3表示右键
    * event.key键值 event.keyCode键码 
    * event.altKey alt键是否按下
    * event.ctrlKey ctrl键是否按下
    * event.shiftKey shift键是否按下
    * pageX/pageY 触发事件时鼠标相对于页面的位置
    * clientX/clientY 触发事件时鼠标相对于可视区域的位置
    * offsetX/offsetY 触发事件时鼠标相对于元素内容区的位置
    * screenX/screenY 触发事件时鼠标相对于屏幕的位置
2. event.stopPropagation()阻止冒泡
event.preventDefault()阻止默认事件
### dom其他方法
1. el.focus()聚焦
2. el.blur()脱离焦点
## BOM
BOM （Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器进行交互的对象，其核心对象是 Window，表示浏览器的一个实例
### 网址URL
1. **URL**：是统一资源定位符（Uniform Resource Locator）的简称，是互联网上标准资源的地址，即网址。
2. 网址组成：
    protocol://host[:port]/path/[?query]#fragment
    + protocol 协议  http:// https://
    + host 主机地址 （每一个主机都有唯一的ip —— ipv4/ipv6）
      将ip美化变成容易记忆的值 —— 域名 -> 浏览器接收域名之后会通过 DNS 系统找到域名对应得IP主机
        域名可以对应不同的功能 ——> 服务器名 + 主域
          - 主页 www.qq.com     www服务器对应的网站主页
          - 邮箱 mail.qq.com    mail邮箱服务器
          - 音乐 music.qq.com / y.qq.com
    + port 端口号 —— 每个软件都会占用主机端口
      - https 默认端口 :443
      - http 默认端口  :80
      上述三者合在一起称为 源(origin)，协议+主机地址+端口号 ——> 对应一个主机房间；
      不同的页面三者完全相同称这两个页面是同源的（协议/主机地址/端口号完全相同）
    + path 路径
    + query 查询参数   ?name=value&name=value
    + fragment 片段 -> 锚点
3. 本地地址与互联网地址：
    + 互联网地址
    + 局域网地址：同一个路由器/交换机下链接的电脑
      - http://192.168.124.75:5500
    + 本地地址
      - http://127.0.0.1:5500
      - http://localhost:5500   loaclhost 就是 127.0.0.1 对应的域名
### window.open()方法
1. **语法**： window.open(strUrl, strWindowName, [strWindowFeatures]);
    * strUrl：要加载的URL
    * strWindowName：任意名/a标签target属性值/iframe的name属性
    * strWindowFeatures：一个描述新窗口特征的字符串
2. 示例：
`<button onclick="window.open('http://bufanui.com')">点击打开新的标签页</button>`
```
btns.onclick = function (){
         // 会打开新页面
        window.open("http://bufanui.com/","_blank", "height=400,width=400");             // 忽略第三个参数,不会打开新页面
        window.open("http://bufanui.com/","_self", "height=400,width=400,");
    }
```
3. **iframe**：相当于在当前界面再嵌套一个界面
`<iframe src="http://mail.163.com" name="ifr" frameborder="0"></iframe>`
```
var newWindow= null;
 btns[3].onclick = function (){
      // 在iframe标签窗口打开页面
      newWindow = open("http://bufanui.com", "ifr");
    }
```
4. open方法有一个返回值，这个返回值代表的是就是打开页面的window对象，如果是同源页面，则可以使用window的方法，如果是非同源页面，只能使用 close / open方法.
通常用newWindow变量存储这一返回值
*注*：非同源页面使用其他方法，会报错Blocked a frame with origin"http://....."from accessing a cross-origin frame.
### history对象
1. 浏览器标签历史记录对象 history
    + length 当前标签页打开的页面数量
    + back() 回退一页
    + forward() 前进一页
    + go(n) 前进/回退n页   n为正数表示前进，负数表示后退，0表示刷新当前页，注意 n 不能超出记录长度，超出则不跳转
    + replace(url)替换当前路径
    + push(url)推送一个新纪录
2. 以 javascript: 开始，后面跟上JS代码，然后以分号结束，可以直接拖拽到标签栏，作为页面脚本使用
3. a标签写上#代表锚点跳转，页面会有历史记录。如果想要a链接点击后什么也不做，则需要使用：
`<a href="javascript:;">跳转到某个点</a>`
### location对象
1. 保存当前窗口正在打开的URL的对象，它既是 window 对象的属性，也是 document 对象的属性（window.location === document.location）
2. **location对象常见属性**：
    + href 代表当前页面的url地址
    + origin 页面的源
        + protocol 协议
        + hostname 主机地址
        + port     端口号
    + pathname 路径
    + search 查询参数   ?name=value&name=value
    + hash   锚点/片段  #xxx
      *注*：参数中如果有中文，location.search 在获取时会将其解析为 %+两个16进制的值 表示的utf-8编码的内容。可使用以下方法对其进行解码和编码
        - encodeURI(内容)  将内容编码为 utf-8 对应的 %+2个16进制 表示的值
        - decodeURI(内容)  将encodeURI编码的内容解码
3. **location对象的方法**：
    1. 窗口跳转：
    * location.assign("url")
    * location.href = "url"
    * location = "url"
    * 前三种方法均会产生历史记录，下面这种方法不会。在当前窗口打开，不会生成历史记录，不可后退即替换当前页面的地址
    * location.replace("url")
    2. 普通刷新：优先从浏览器本地缓冲获取资源
    * F5
    * history.go(0)
    * location.reload(false)
    3. 强制刷新：无论本地是否有缓存，总是强制从服务器获取资源
    * ctrl+F5
    * location.reload(true)
4. 利用location.search实现页面传值
了解URLSearchParams()方法
new URLSearchParams(对象).toString() => 转化为符合location.search格式的字符串
`location.href += "?" + new URLSearchParams(obj);`
new URLSearchParams(location.search) => 转化为可以for of遍历的键值对
```
var obj = {}
      var searchObj = new URLSearchParams(location.search);
      for(var keyArr of searchObj){
        console.log(keyArr); // [key, value]
        obj[keyArr[0]] = keyArr[1];
      }
      console.log(obj);
```
*补充*：获取url参数的两种办法：
```
function getParams(url) {
  const res = {}
  if (url.includes('?')) {
    const str = url.split('?')[1]
    const arr = str.split('&')
    arr.forEach(item => {
      const key = item.split('=')[0]
      const val = item.split('=')[1]
      res[key] = decodeURIComponent(val) // 解码
    })
  }
  return res
}
```
```
const url = new URL(`http://www.programmer.com?a=1&b=2`);
const searchParams = new URLSearchParams(url.search);
const params = Object.fromEntries(searchParams.entries());
console.log(params)
```
*注*：entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。
迭代对象中数组的索引值作为 key， 数组元素作为 value。而fromEntries是将可迭代键值对转为对象
### navigator对象
包含有关访问者浏览器的信息
1. navigator.online判断用户是否在线，返回一个可读的布尔值
2. 通常用于判断用户是安卓端还是PC端，或者使用的是什么浏览器
```
// 获取浏览器用户代理头片段，将其变为小写字符串
    var browserName = navigator.userAgent.toLowerCase();
    //区分手机端还是PC端
    var isMobile = (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(browserName)),
    //判断浏览器
    isFirefox = /firefox/i.test(browserName),
    isChrome = /chrome/i.test(browserName) && /webkit/i.test(browserName) && /mozilla/i.test(browserName);
    
    console.log("是否是 chrome", isChrome);
    console.log("是否是 firefox", isFirefox);
    console.log("是否是 mobile", isMobile);
```
### window的其他方法
* onload： 页面所有内容加载完毕后触发改事件
* onunload： 用户退出页面触发该事件
* widnow.onresize：当页面窗口大小发生变化的时候会触发该事件
* scrollBy(xnum, ynum)：可把内容滚动指定的像素数。
* scrollTo(x, y)：可把内容滚动到指定的坐标。
### 请求动画帧
1. **requestAnimationFrame**：一般浏览器的刷新频率是 60HZ，window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

   *注*：相比于setInterval，该方法在写动画时更节省性能。raf在当前标签页被隐藏时不执行

2. **语法**：`var requestId = requestAnimationFrame(callback);`
*注*：callback 默认得到一个参数 —— 从页面加载开始经过的毫秒数。这个时间戳也可通过调用 performance.now() 得到。
### 正则表达式
正则 —— 从字符串中匹配某些内容，将内容总结为规律 
1. 创建正则
    1. 字面量形式创建   var reg = /a/ig
    2. 构造函数的方式创建 var reg = new RegExp("a","ig");
    *注*：属性 “g”、”i” 、”m”、”u” 和 “y”，分别用于指定全局匹配、忽略大小写的匹配、多行匹配、开启完整的 unicode 支持和粘滞模式。注意：“u” 在 Firfox 和 Edge 浏览器中缺乏支持
2. 方法
    * str.search(reg)返回找到的匹配项的索引位置，如果没找到则返回 -1。总是查找第一个匹配项。
    * regexp.test(str)检验字符串是否有符合正则条件的字符串片段，返回 true/false
    * str.match(reg)返回符合正则表达式的字符串片段.查找不到则返回null
    *注*：
    不使用 "g" 修饰符的时候，结果是一个数组，里面有该匹配项和额外的属性：
    index – 匹配项在字符串中所处在的位置，
    input – 原始字符串。
    当使用 "g" 修饰符的时候，str.match 就会返回由所有匹配项组成的数组
3. 元字符
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>查找单个字符，除了换行和行结束符。</td>
</tr>
<tr>
<td>\w</td>
<td>查找单词字符。英语字母表中的一个字母或者一个数字或一个下划线</td>
</tr>
<tr>
<td>\W</td>
<td>查找非单词字符。</td>
</tr>
<tr>
<td>\d</td>
<td>查找数字。</td>
</tr>
<tr>
<td>\D</td>
<td>查找非数字字符。</td>
</tr>
<tr>
<td>\s</td>
<td>查找空白字符。</td>
</tr>
<tr>
<td>\S</td>
<td>查找非空白字符。</td>
</tr>
</tbody></table>

例：
```
console.log(str.match(/./g));
console.log(str.match(/\d/g));
console.log(str.match(/\D/g));
```
4. 正则补充
    * /json/.test(params.contentType) 检测是否为json类型
    * /form/.test(params.contentType) 检测是否为表单数据类型
## H5&&C3补充
### 元素可编辑模式
我们通过给元素设置 contentEditable 属性可以开启元素的编辑模式，让用户更改元素的文本内容。

`<p contenteditable="true">竹外桃花三两只，春江水暖鸭先知</p>`
如果想让页面内所有元素的文本内容都可以被编辑，可以直接使用文档编辑模式：

`document.designMode = "on";`
### 全屏（有兼容写法）
1. **开启全屏**： E.requestFullscreen(); *注*：E为元素
2. **关闭全屏**： document.exitFullscreen(); *注*：不能使用元素， 须用document
3. **判断全屏**：
```
function ifFullscreen(){
    return document.fullscreen || document.webkitIsFullScreen || document.mozFullScreen || false;
}
```
4. **全屏状态元素伪类选择器**：
```
/* 全屏状态下宽高、位置属性不可更改 */
    .box:fullscreen {
        background-color: #ff9000;
    }
```
### 新的拖拽属性
1. 给元素设置 draggable="true" 属性来让元素变成可拖拽元素，拖拽元素拥有以下常用监听事件：
    * 自身的监听事件
    <table>
    <thead>
    <tr>
    <th>事件名</th>
    <th>说明</th>
    </tr>
    </thead>
    <tbody><tr>
    <td>dragstart</td>
    <td>用户开始拖拽时触发，鼠标按下并开始移动</td>
    </tr>
    <tr>
    <td>drag</td>
    <td>整个拖拽过程都会调用，鼠标按下到抬起期间持续触发</td>
    </tr>
    <tr>
    <td>dragleave</td>
    <td>当鼠标离开目标元素时触发</td>
    </tr>
    <tr>
    <td>dragend</td>
    <td>当拖拽结束时触发，此时鼠标抬起</td>
    </tr>
    </tbody></table>
    * 与其他元素的交互
    <table>
    <thead>
    <tr>
    <th>事件名</th>
    <th>说明</th>
    </tr>
    </thead>
    <tbody><tr>
    <td>dragenter</td>
    <td>鼠标携带拖拽元素拖拽元素进入当前元素时触发</td>
    </tr>
    <tr>
    <td>dragover</td>
    <td>鼠标携带拖拽元素在当前元素上停留时触发</td>
    </tr>
    <tr>
    <td>dragleave</td>
    <td>鼠标携带拖拽元素离开当前元素时触发</td>
    </tr>
    <tr>
    <td>drop</td>
    <td>在当前元素上松开鼠标，释放拖拽元素时触发</td>
    </tr>
    </tbody></table>

    使用实例(需要在事件前加on)：
    ```
        box.ondragstart = function (){
            console.log("拖拽开始");
        }
    ```
3. 浏览器默认禁止元素堆叠，drop事件默认被阻止。如果想让drop事件执行，需要在 dragover 事件中阻止默认
4. **拖拽传值**：我们可以通过 dataTransfer 拖拽内容对象来实现在拖放操作过程中的数据交换。此对象是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据，使用方法：
    * `setData(type, value)`：向 dataTransfer 对象中存入数据。接收两个参数，第一个表示要存入数据种类的字符串，第二个参数为要存入的数据。
    * `getData(type)`：从 dataTransfer 对象中读取数据。参数为在 setData 中指定的数据种类。
    * `clearData()`：清除 dataTransfer 对象中存放的数据。参数可选，为数据种类。若参数为空，则清空所有种类的数据。
    例：
```
        select.ondragstart = function (){
            event.dataTransfer.setData("text", "天王盖地虎");
        }
        box.ondragover = function (){
            return false;   // 取消默认事件的另一种写法
        }
        box.ondrop = function (){
            box.innerText = event.dataTransfer.getData("text");
        }
```
### Web存储
1. **localStorage**: 将内容存储到本地
    + 存储的内容不删除一直可用
    + 同源页面共享
2. **sessionStorage**: 将内容存储在临时页面中
    + 存储的内容随着页面关闭被清空
    + 每个页面都有单独的存储
3. 通过 控制台中的 Application 左侧栏的 local、session 查看存储内容
    它们存储的方式是键值对
4. 二者通用方法：
      setItem(key, value)   设置
      getItem(key)          获取
      removeItem(key)       删除
      clear()               清空
      length 存储内容的长度 
      key(index) 根据下标获取键名
      实例：
```
btns[7].onclick = function (){
      for(var i = 0; i < localStorage.length; i ++){
        // 通过下标获取存储的键名
        var key = localStorage.key(i);
        var value = localStorage.getItem(key);
        console.log("存储的键名有：", key, "键值为：",value);
      }
    }
```
    *注*：上述方法均可以通过 对象本身进行修改（不推荐，因为可能无法触发某些存储监听事件）
      localStorage.key = value
5. 存储引用类型数据时应用JSON数据类型
```
localStorage.setItem("arr", JSON.stringify([1,2,3,4]));
localStorage.setItem("obj", JSON.stringify({ name: "object" }));
console.log(JSON.parse(localStorage.getItem("arr")));
console.log(JSON.parse(localStorage.getItem("obj")));
```
6. **监听存储事件**：本地存储内容发生改变时，会触发同源页面的storage事件
*注*：当前页面是不会触发的，必须是另外一个同源页面。可用于页面传消息。 如果存储的内容值与原值相同，不会触发storage
```
window.addEventListener("storage", function (e){
      console.log("存储修改的键名", e.key);
      console.log("存储修改的键值原始值", e.oldValue);
      console.log("存储修改的键值新值", e.newValue);
      localStorage.setItem("message", "I'm fine, and you?");
    })
```
### 非选择器
1. :not() 伪类可以将一个或多个以逗号分隔的选择器列表作为其参数。选择器中不得包含另一个否定选择符或伪元素。
*注意*：以逗号分隔的选择器列表作为参数是实验性的，尚未获得广泛支持。
```
/* 非 <p> 元素 */
    body :not(p) {
      text-decoration: underline;
    }

    /* 既不是 <div> 也不是 <span> 的元素 */
    body :not(div):not(span) {
      font-weight: bold;
    }
```
2. 可利用非选择器实现选中状态和非选中状态下span标签的状态
```
<style>
        .content.checked span:last-of-type {
            display: none;
        }

        .content:not(.checked) span:first-of-type {
            display: none;
        }
</style>
<div class="content">
        <input type="checkbox" class="ipt">
        <span>选中状态</span>
        <span>非选中状态</span>
    </div>
    <script>
        var content = document.querySelector(".content");
        var input = document.querySelector(".ipt");
        input.onchange = function () {
            content.classList.toggle("checked");
        }
</script>
```
### 计算长度函数calc
`width:calc(100%-50px);`
+ 计算遵循数学优先级
+ 计算可以用于任何表示长度的位置（包括时间）
+ 运算符前后必须加空格
+ 带单位的可以互相加减，不能乘除
+ 带单位和一个数字可以乘除，不能加减
### css变量
1. 定义变量
```
html {
      /* html是最大的页面容器，因此一般在这里定义全局CSS变量 */
      --w: 200px;
      --color: #333;
      --font: italic bold 30px/2 "楷体";
      --bg: #fff;
    }

    .box {
      /* 
      --变量名: CSS样式值; 定义一个css变量
      var(--变量名) 使用变量
      */
      --width: 300px;
      width: var(--w);
      height: 200px;
      color: var(--color);
      background-color: var(--bg);
    }
```
* 同一个CSS变量，可以在多个选择器内声明，依照CSS优先级使用
* 变量不赋值代表空值，并不会报错。initial 是变量的无效值，使用了空值或无效值的样式会自动转换为该样式的默认初始值；例如引用变量`--width: ;（注意引号前面的空格）`会使用默认的宽度样式。
* 还可以定义默认值，只需在变量后面跟上逗号，加上默认值即可：
```
element {
    width: var(--width, 200px); //若width无效，则使用200px
}
```
2. 获取和修改变量
```
// 获取元素内联/外联样式设置的的 CSS 变量
getComputedStyle(element).getPropertyValue("--my-var");

// 修改一个 DOM 节点上的 CSS 变量
element.style.setProperty("--my-var", value);
```
### css动画
先在css定义关键帧，再在相应动画元素的CSS属性中添加animation属性
1. 语法
```
@keyframes 动画名{
    0%/from {
        动画样式起始状态
    }
    任意百分比 {
        css code ...
    }
    100%/to {
        动画样式终止状态
    }
}
```
2. 关键属性
* animation-name 动画名称(必填)

* animation-duration 动画持续时间(必填)

* animation-timing-function
    * linear/ease/ease-in/ease-out/ease-in-out/cubic-bezier(n,n,n,n)： 特定的贝塞尔曲线类型
    
* animation-delay 动画延迟（只是第一次）
  
* animation-iteration-count 重复次数
    * 1/2/3/4…
    * infinite 无限次
    
* animation-direction 动画是否重置后再开始播放
    * normal 动画每次都从 0% 的状态开始执行
    * alternate 动画从起点开始，往复运动
    * alternate-reverse 动画从终点开始，往复运动
    
* animation-fill-mode 动画执行完毕后状态
    * forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义） - 未实现，当前效果类似于 both。
    * backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。
    * both 设置对象状态为动画结束或开始的状态，结束时状态优先
3. 简写语法
```
.ele {
    animation: name duration timing-function delay iteration-count direction fill-mode;
}
//name duration 是必填属性，其它的属性是都可选属性。
```
4. 动画状态
animation-play-state 动画状态（running 执行 和 paused 暂停）
5. 帧动画
在应用 CSS3 动画时，有个控制时间的属性 timing-function 。它的取值中除了常用到的 贝塞尔曲线 以外，还可以是 steps() 函数
steps(n,start/end)
​ 第一个参数 number 为指定的间隔数，即把动画分为 n 步阶段性展示。第二个参数通常不写,也不用记
6. 动图效果实现：原理为事先将动画分解为一张张图片，移动背景图片的位置，形成动作
```
 @keyframes up {
      0% {
        background-position-y: 0;
      }
      100% {
        background-position-y: calc(-273px * 4);
      }
    }
```
7. **动画监听**
animationstart、animationiteration、animationend
**过渡监听**
transitionrun、transitionstart、transitionend
```
box.addEventListener("animationstart", function (e){
      console.log(e.type, "延时过后，动画开始");
    })

    // 过渡监听
    inner.addEventListener("transitionrun", function (){
      console.log("过渡被触发");
    })
```
## flex布局
### 容器属性
1. 语法:`display: flex;`
2. 布局由主轴与交叉轴构成
3. **主轴排序**：justify-content:flex-start | flex-end | center | space-between | space-around | space-evenly(实验属性);
4. **交叉轴排序**：align-items: flex-start | flex-end | center | baseline | stretch;
5. **换行**： flex-wrap: nowarp | wrap（第二行在下方） | wrap-reverse（第二行在上方）;
6. **多轴线排列**：类似于多个主轴线在交叉轴上的排布
align-content: stretch | flex-start | flex-end | center | space-between | space-around | space-evenly
7. **主轴方向**：flex-direction: row | row-reverse | column | column-reverse;
*注*：flex-direction设置为column或者column-reverse时，justify-content的生效方向的也随着变化
8. 复合写法flex-flow = flex-drection + flex-wrap
例`flex-flow: row nowrap;`
9. 解决flex容器最后一行的对齐问题，通常增加n-2个元素，将元素高度变为0，flex容器只要有宽度就能占据位置，利用此原理实现最后一排对齐。
### 元素属性
1. order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0
2. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
align-self: auto | flex-start | flex-end | center | baseline | stretch;
*注*： align-self的权重高于父元素的align-item
3. flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。无多余宽度时，flex-grow无效。
4. flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效
5. flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间
*注*：最小不能小于内容宽
*注*：主轴为横向，则设置宽；主轴为纵向，则设置高
6. 复合写法flex；
flex=flex-grow+flex-shrink+flex-basis
该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。也可以只写一个值，具体分配可用浏览器查看
7. margin在flex布局中的表现：margin设置auto值，会平均分配flex容器在对应方向的剩余空间
设置了某个方向 margin: auto之后，对应方向的布局就会失效
8. flex布局后，盒子溢出的部分不会撑开盒子，而是以类似定位的形式超出展示，遵循后面的盒子压住前面的盒子的原则
##  jQuery
jQuery 是一个快速、简洁的 JavaScript 框架。它封装 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互。
其实就是学习 jQuery 封装好的那些功能方法，这些方法叫做 API（Application Programming Interface 应用程序编程接口）。
### jQuery的引入
1. 下载到本地引入
获取源文件
引入页面，同时注意引用顺序，引入之后才能使用
`<script src="./jquery-3.3.1.min.js" />`

2. CDN引入
找到可靠的CDN提供商，如：https://www.bootcdn.cn/
复制CDN地址，粘贴到页面中
`<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>`
*注*：jquery.js 和 jquery.min.js 的区别：
jquery.js是完整的未压缩的jQuery库，文件比较大，一般用于阅读学习源码或修改源码，一般不用于线上项目。
jquery.min.js是由完整版的jQuery库经过压缩得来，压缩后功能与未压缩的完全一样，只是将其中的空白字符、注释、空行等与逻辑无关的内容删除，并进行一些优化。这个版本一般用于网站引用使用，减小文件体积，降低网站流量，提升访问速度等。
*注*：可以通过 $.fn.jquery 来查看 jQ 版本
### jQuery选择器
1. $、jQuery
jQ 提供了两个变量 $ 和 jQuery 给开发者使用，一般情况下使用 $ 变量即可；如果遇见其它库提供了 $ 变量，未防止冲突，可以使用 jQuery 变量。
用法`$(selector/fn)`
*注*：以函数作为参数时，作用相当于页面的入口函数，当页面内容加载完成后执行接受的函数。
与 window.onload 的区别：
*  执行时间
window.onload 必须等到页面内包括图片的所有元素加载完毕后才能执行。
`$(function(){}）` 是 DOM 结构绘制完毕后就执行，不必等到加载完毕。因此执行时间比上面的快。
*  编写个数
window.onload 只能设定一个，jQ 入口函数可以同时编写多个，并且都可以得到执行。
2. 属性选择器
    * `$(‘a[href!=’baidu’]’)`href 属性不为’baidu’的 a 标签,包括不具有 href 属性的 a 标签
    * `$(‘a[href][title=’内容’]’)`具有 href 属性且 title 属性为’内容’的 a 标签
3. 基本筛选选择器
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:left">说明(index 从 0 开始)</th>
</tr>
</thead>
<tbody><tr>
<td>:eq(index)</td>
<td style="text-align:left">匹配一个给定索引值的元素</td>
</tr>
<tr>
<td>:gt(index)</td>
<td style="text-align:left">匹配所有大于给定索引值的元素</td>
</tr>
<tr>
<td>:lt(index)</td>
<td style="text-align:left">匹配所有小于给定索引值的元素</td>
</tr>
<tr>
<td>:odd</td>
<td style="text-align:left">匹配所有索引值为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td style="text-align:left">匹配所有索引值为偶数的元素</td>
</tr>
<tr>
<td>:first</td>
<td style="text-align:left">获取匹配的第一个元素</td>
</tr>
<tr>
<td>:last</td>
<td style="text-align:left">获取匹配的最后一个元素</td>
</tr>
</tbody></table>

4. 其他选择器
* :empty	匹配所有不包含子元素或者文本的空元素	`$(‘li:empty’)`
* :contains(text)	匹配包含给定文本的元素	`$(‘li:contains(‘john’)’)`
### jQuery对象
1. ：通过 $(选择器) 可以获取到选择器内容对应的 jQ 对象，jQ 对象是由符合选择器条件的所有 DOM 元素组成的伪数组。
*注*：可以直接使用`$("<div></div>")`创建jQuery对象
2. 我们可以接受 DOM 对象作为参数将其转化为 jQ对象：
```
var ulEle = document.querySelector("ul");
// 将ulEle 转换为 jQ对象
console.log($(ulEle)); // $.fn.init [ul]
```
3. 从jQ对象中取除dom对象
    1. 使用`$btn[0]`
    2. 使用`$btn.get(0)`
### jQuery对象操作
1. 筛选关系节点
<table>
<thead>
<tr>
<th>属性(都有括号)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eq(index)</td>
<td>获取当前 jQ 数组中下标为 index 的 jQ 对象</td>
</tr>
<tr>
<td>find（“选择器”）</td>
<td>返回符合条件的 jQ 对象的子节点</td>
</tr>
<tr>
<td>parent</td>
<td>返回 jQ 对象的父节点</td>
</tr>
<tr>
<td>parents</td>
<td>返回 jQ 对象的所有父节点</td>
</tr>
<tr>
<td>parentUntil</td>
<td>返回 jQ 对象的直到指定值所有父节点</td>
</tr>
<tr>
<td>children</td>
<td>返回 jQ 对象的所有子节点</td>
</tr>
<tr>
<td>prev</td>
<td>返回 jQ 对象上一个兄弟节点</td>
</tr>
<tr>
<td>prevAll</td>
<td>返回 jQ 对象的前面所有的兄弟节点</td>
</tr>
<tr>
<td>prevUntil</td>
<td>返回 jQ 对象的前面直到指定值所有的兄弟节点</td>
</tr>
<tr>
<td>next</td>
<td>返回 jQ 对象下一个兄弟节点</td>
</tr>
<tr>
<td>nextAll</td>
<td>返回 jQ 对象后面所有的兄弟节点</td>
</tr>
<tr>
<td>nextUntil</td>
<td>返回 jQ 对象后面的直到指定值的所有的兄弟节点</td>
</tr>
<tr>
<td>siblings</td>
<td>返回当前 jQ 对象所有的兄弟节点</td>
</tr>
</tbody></table>

2. 样式操作
    * $ele.css("样式名") 获取元素的样式
    * $ele.css("样式名", "样式值")  设置单个元素样式
    * $ele.css({  一次设置多个元素的样式
    "样式名": "样式值",
    "样式名": "样式值",
    "样式名": "样式值"  
    })
    *注*：样式的单位可以省略
    * $ele.width() / $ele.height() 获取/设置元素的宽高，值不带单位
    * $ele.offset() 获取/设置元素与页面的上左边距
    ```
     $box.offset({
        top: 50,
        left: 50
      })
    ```
    *注*：设置时，如果有定位，直接改top / left；  如果没有定位，给元素添加相对定位，然后改top/left
    *  $ele.position() 返回元素有定位时，top/left的值
    * $ele.scrollTop/Left() 获取/设置元素卷入上左距离 `$content.scrollTop(300);`
    *注*：也可以应用于动画
    ```
     $content.animate({
        scrollTop: 300,
        scrollLeft: 300
      })
    ```
3. 属性操作
    * $ele.attr("属性名") 获取属性值
    * $ele.attr("属性名", "属性值") 设置单个属性
    * $ele.attr({ 设置多个属性值
    "属性名": "属性值",
    "属性名": "属性值",
    "属性名": "属性值",
    "属性名": "属性值"
    })
    * $ele.removeAttr("属性名")  删除属性
    *注*：attr 可以更换为 prop。两者的区别如下：
    attr 设置的非官方定义属性会出现在元素标签上，prop 设置的非官方定义属性会出现在元素对象上
    attr 获取表单选择属性返回设置的值，prop 获取表单选择属性返回 boolean 值
    *注*：attr、prop设置的自定义属性不能通过对方获取
4. 类名操作
    * $ele.addClass() 向被选元素添加一个或多个类
    * $ele.removeClass()  从被选元素删除一个或多个类
    * $ele.hasClass()  判断被选元素是否存在类
    * $ele.toggleClass()  对被选元素进行添加/删除类的切换操作
5. 元素操作
    1. 添加元素
    <table>
    <thead>
    <tr>
    <th>方法</th>
    <th>作用</th>
    </tr>
    </thead>
    <tbody><tr>
    <td>before（）</td>
    <td>在 jQ 对象之前插入内容</td>
    </tr>
    <tr>
    <td>prepend（）</td>
    <td>在 jQ 对象的第一个子节点之前插入内容</td>
    </tr>
    <tr>
    <td>append（）</td>
    <td>在 jQ 对象的最后一个子节点之后插入内容</td>
    </tr>
    <tr>
    <td>after（）</td>
    <td>在 jQ 对象之后插入内容</td>
    </tr>
    <tr>
    <td>replaceWith（）</td>
    <td>使用内容替换该 jQ 对象</td>
    </tr>
    </tbody></table>

    *注*：括号里的参数可以是：jQ对象/HTML字符串/普通文本/DOM， 而dom的操作方法中的参数只能是后两者
    *注*：如果被插入内容是某个已经拥有父节点的节点，在被传递给此方法后，它首先会被移除，再被插入到新的位置。
    2. 克隆节点
    `$ele.clone(是否克隆jQ添加的事件)`
    *注*：如果括号内为true，那么在克隆时会连同原元素身上的事件一并克隆
    3. 删除节点`$ele.remove()`
6. 元素内容操作
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$ele.html()</td>
<td>获取或设置元素内容HTML字符串</td>
</tr>
<tr>
<td>$ele.text()</td>
<td>获取或设置元素内容文本字符串</td>
</tr>
<tr>
<td>$input.val()</td>
<td>获取或设置input输入框的value值</td>
</tr>
</tbody></table>

### jQuery事件
1. 绑定事件的两种方式
    1. jQ对象.事件名(参数)
    `$ele.事件名([data], [fn])` data：供函数使用的参数对象 fn：事件处理函数
    ```
    $btn.click({ data: "这是传入的参数" }, function(e){
        console.log(e.data); // { data: "这是传入的参数" }
        console.log(e); // 这是 jQ 的事件对象
        console.log(event); // 这是 window 的事件对象，即我们之前讲过的
    })
    ```
    2. jQ对象.on(事件名，其它参数)
    `$ele.on(type, [selector], [data], fn)`
    type：事件名，可以是一个或者多个。
    selector：一个选择器字符串，委托事件的元素选择器，可选。
    data：事件参数，可选。
    fn：该事件被触发时执行的函数。
    ```
     // on方式允许同时绑定多个不同类型的事件
        $btn.on("mouseenter mouseleave", function (){
            $(this).toggleClass("act");
        })
    
        // 使用事件委托，点击li让颜色变红
        $ul.on("click", "li", function (){
            this.style.color = "#f00";
        })
    ```
    *注*：上例中委托后this和target都指向li
    
    *注*：this指向的时DOM对象，$(this)指向的才是jQuery对象
    *注*：采用事件委托的另一个优点：后来添加的子元素也有事件，不需要再重新绑定
    
2. off 解绑事件
jQ 使用 $ele.off() 方法移除给当前对象绑定的事件处理函数
```
// 取消 button 上绑定的所有事件
$btn.off();
// 取消一类特定的事件
// $btn.off("click");
// 取消特定事件的具名处理函数
// $btn.off("click", clickHandle);
// 取消事件委托
// $ul.off("click", "li");
```
3. 事件对象
jQ 事件中的事件对象通过事件处理函数的形参获取，事件中的 event 是 window 上的属性，与原生事件中的事件对象一致。
jQ 事件对象常用属性也与之前学过的 DOM 事件对象几乎一致，多了一个 data 属性用于获取事件绑定时传入的参数。
4. 事件中的 this
jQ 事件中的 this 指向绑定事件的 jQ 对象代表的 DOM 对象，如果使用 on 方式添加的事件委托，委托事件处理函数中的 this 指向委托元素的 DOM 对象。
5. 事件特点
jQuery 允许给同一个 jQ 对象的同一个事件绑定多个不同的事件处理函数
### jQuery特性
1. 链式调用
原理：每次执行完函数都会返回调用函数的 jQ 对象，这样可以在函数调用之后继续使用该对象的其它方法。
*注*：需要注意的是在链式操作过程中 jQ 对象会转移，不一定是初始调用函数的对象。
例：
```
      $(".box").click(function() {
        $(this)
            .css("width", "80px")
            .attr("title", "box")
            .next() // 此函数返回 $h2 对象
            .addClass("title")
            .css("color", "#f00")
    });
```
运行之后发现 h2 标题的类名增加了 title，且字体颜色变红了。这是因为我们使用了 next 方法获取了 box 元素的下一个兄弟节点，之后的操作对象就变成了 h2 对象。
*注*如果希望对象转移后在返回转移前的对象可以使用 end() 方法：
```
$(".box") // 当前返回$box
    .next() // 返回 $h2
    .addClass("title")
    .end() // 将 $h2 换回 $box
    .css("color", "#f00")
```
2. 隐式迭代
jQ 对象是有符合筛选条件的 DOM 元素组成的伪数组，为该 jQ 对象添加的任何方法，都会在方法的内部会遍历节点数组，为其中的每一个的元素执行相应的方法。
```
        $("li").css("color", "#f00"); // 每一个li的颜色都会改成红色
```
### jQuery动画
1. 语法：`$(selector).animate(stylesObj,[duration],[timing-function],[callback])`
    * stylesObj：要执行动画的 CSS 属性与它设定的终点值组成的对象
    * duration：执行动画时长，值为三种预定速度之一的字符串(“slow”、”normal”、”fast”)或表示动画时长的毫秒数值（可选）
    * timing-function：动画运动速率函数，只有两个值： swing 和 linear（可选）
    * callback：动画执行完后立即执行的回调函数（可选）
2. 动画插件：jQuery 不能给元素颜色样式添加动画，动画的速率曲线也只有两种，如果我们想要更改元素的颜色，或者添加更多样的运动轨迹效果，需要借助插件实现。
常见的两个插件为：jquery.color.js 和 jquery.easing.js。前者为 jQ 添加颜色动画，后者扩展了时序函数。
*注意*：插件的使用依赖于 jQuery，因此引入插件要在引入 jQuery 文件之后。
3. 动画队列：jQuery 默认提供针对动画的队列功能。即如果我们在一个函数内给元素添加了多个 animate() 调用，jQuery 会创建包含这些方法调用的“内部”队列。然后逐一运行这些 animate 调用。
4. 动画延时`$ele.delay(time)`
```
$box.click(function (){
    $(this).delay(2000).animate({
        opacity: .2
    }, 3000)
})
```
5. 动画停止：
* `$ele.stop(stopAll, goToEnd)`
    * stopAll：是否全部停止动画(清除队列中所有动画)，默认 false。即仅停止活动的动画，允许任何排入队列的动画向后执行。
    * goToEnd：是否立即完成当前动画，即将当前动画的样式直接设置为终点值，默认 false。
* `finish`
此方法会立即停止动画队列中所有动画，并将元素样式设置为所有动画的终点值叠加后的状态，如果多个动画改变了同一个属性，以最后一个动画的结束样式为准。
语法： `$ele.finish()`
6. 快捷动画
<table>
<thead>
<tr>
<th>动画名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>show</td>
<td>让元素出现</td>
</tr>
<tr>
<td>hide</td>
<td>隐藏元素</td>
</tr>
<tr>
<td>toggle</td>
<td>切换元素出现与隐藏</td>
</tr>
<tr>
<td>slideDown</td>
<td>元素滑入，类似放下卷门帘</td>
</tr>
<tr>
<td>slideUp</td>
<td>元素滑出，类似上卷门帘</td>
</tr>
<tr>
<td>slideToggle</td>
<td>切换元素的滑入滑出</td>
</tr>
<tr>
<td>fadeIn</td>
<td>元素渐现</td>
</tr>
<tr>
<td>fadeOut</td>
<td>元素渐隐</td>
</tr>
<tr>
<td>fadeToggle</td>
<td>切换元素的淡入淡出效果</td>
</tr>
<tr>
<td>fadeTo（时长，透明度）</td>
<td>切换元素的淡入淡出效果</td>
</tr>
</tbody></table>

*注*：上述方法均接受三个可选参数：duration、timing-function、fn，三个参数与 animate 动画的参数效果一致
*注*：让元素出现和隐藏的动画默认是直接改变元素的 display 属性的，即闪现动画。添加上时间才能看到动画过程。
```
        $("button:eq(0)").click(function (){
            $box.show(1000, function (){
                console.log("出现了");
                $box.animate({
                    backgroundColor: "#00f"
                })
            });
        })
```
### jQuery方法
1. $.map( object或者arr, callback(n,i) )
用于使用指定函数处理数组中的每个元素(或对象的每个属性)，并将处理结果封装为新的数组返回。其中n为当前值，i为当前值索引（若是对象，则为属性名和属性值）
2. $.each( object或者arr, callback(n,i) )
与$.map类似，只不过不会返回新数组
3. $(this).index(元素，对象或选择器)获取当前元素在jQuery数组中的下标，如括号内未指定参数，则默认返回当前元素在其所有同辈元素的索引位置。
4. $("表单类名").serialize()获取表单的数据，是以&连接的形式。表单中的元素必须都有name属性。
5. $(".box").empty()清空所有子节点和内容
## 插件
都是依赖于jQuery的插件，类似的可以去jq22.com上找或者自己写
### Swiper轮播插件
1. 加载配置文件：使用 Swiper 插件需要先引入它的依赖文件 – swiper.css 和 swiper.js，可以将其下载到本地或者使用 CDN 方式。
```
<head>
    ...
    <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css">
</head>
<body>
    ...
    <script src="https://unpkg.com/swiper/swiper-bundle.min.js"> </script>
    ...
</body>
```
2. 页面结构
```
<div class="swiper">
    <div class="swiper-wrapper">
        <div class="swiper-slide">Slide 1</div>
        <div class="swiper-slide">Slide 2</div>
        <div class="swiper-slide">Slide 3</div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>
    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
    
    <!-- 如果需要滚动条 -->
    <div class="swiper-scrollbar"></div>
</div>
```
3. 初始化
```
 var mySwiper = new Swiper(".swiper", {
            loop: true,//是否可以循环轮播，默认false
            direction: "horizontal", // Swiper的滑动方向，可设置为水平方向切换(horizontal)或垂直方向切换(vertical)，默认：horizontal
    speed: 1000,  // Swiper切换效果的持续时长，默认：300
    autoHeight: true// 自动高度，设置为 true 时，wrapper和container会随着当前slide的高度而发生变化。默认：false
    autoplay: true  //自动轮播，默认flase
    可设置为对象，以添加其他属性
    autoplay: {
    // 设置自动切换的事件间隔，默认 3000
    delay: 1500,
    // 当切换到最后一个slide时是否停止自动切换。（loop模式下无效）。默认：false
    stopOnLastSlide: true,
    // 用户操作swiper之后，是否禁止autoplay。默认为true：停止。
    disableOnInteraction: false,
    // 是否开启反向自动轮播：即轮播到一端边界时是否反向运动回去
    reverseDirection: true
}
//初始化导航键
            navigation: {
                nextEl: ".swiper-button-next",//或者是自己的自定义类名
                prevEl: ".swiper-button-prev"
            },
            //初始化分页器
            pagination: {
                el: ".swiper-pagination",
                clickable: true,    //是否可以通过分页器控制页面
            }
        })
```
*注*：还有一部分关于分页器的详细设置可参考swiper官网和腾讯课堂4.18日回放
4. swiper在vue中的小问题
若使用v-for生成swiper,vue数据更新后,swiper不会刷新数据，还会导致异常。可调用swiper自带的update方法解决
```
created() {
    getBanner().then((res) => {
      console.log(res);
      this.bannerList = res.banners;
      this.$nextTick(() => this.mySwiper.update());
    });
  },
  //但使用该方法会影响轮播的loop，因为每次update后loop都会重置为false。建议还是等数据获取后再初始化swiper
```
### Animate.css插件
1. 使用方式：
    1. 引入文件 – 下载到本地 / 使用CDN
    `<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />`
    2. 给希望使用动画的元素添加上 animate__animated 和 animate__动画名 的类名：
    `<h1 class="animate__animated animate__bounce">An animated element</h1>`
2. 实例
```
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
<style>
    .box {
        width: 150px;
        height: 150px;
        margin: 50px;
        backgrond-color: #f00;
    }
    .box:hover {
        /* jello 是 animate.css 提供的动画名 */
        animation-name: jello;
    }
</style>
<body>
    <div class="box animate__animated"></div>
</body>
```
3. 更换持续时长、延时和重复时间请查看官网文档https://animate.style/
4. 动画所依赖的三个基础变量：--animate-duration:1s; --animate-delay:1s; --animate-repeat:1;
可以在root中更改这三个变量，全局的动画都会变`:root{--animate-duration:2s}`
*注*；其实可以自己定义元素css的动画属性，只借用动画库里相应的动画名，比如
`animation:fadeInLeft 1s 2s Infinite;`
### WoW.js出场动画插件
1. 使用方式：
    1. 引入 animate.css 和 wow.js，或者使用它们的CDN
    2. 给要添加出场动画的元素添加 wow 和从 animate.css 动画库中筛选的出场动画的动画名
    3. 初始化 wow：new WOW({配置参数}).init()
    配置参数如下
    <table>
    <thead>
    <tr>
    <th>属性名</th>
    <th>默认值</th>
    <th>说明</th>
    </tr>
    </thead>
    <tbody><tr>
    <td>boxClass</td>
    <td>“wow”</td>
    <td>当用户滚动时让元素显示的类名</td>
    </tr>
    <tr>
    <td>animateClass</td>
    <td>“animated”</td>
    <td>CSS动画的持续时长的类名</td>
    </tr>
    <tr>
    <td>offset</td>
    <td>0</td>
    <td>定义浏览器视口底部与隐藏元素顶部之间的距离，符合条件元素出现</td>
    </tr>
    <tr>
    <td>mobile</td>
    <td>true</td>
    <td>是否在移动端可用</td>
    </tr>
    <tr>
    <td>live</td>
    <td>true</td>
    <td>是否给新添加符合条件的元素添加出场动画</td>
    </tr>
    </tbody></table>

2. 实例
```
<link rel="stylesheet" href="./animate.css">
<style>
    .box{
        float: left;
        margin: 200px;
        width: 150px;
        height: 150px;
        background-color: #f00;
    }
</style>
<body>
    <div class="box wow animate__backInDown"></div>
    <div class="box wow animate__backInLeft"></div>
    <div class="box wow animate__backInRight"></div>
    <div class="box wow animate__fadeInDown"></div>
    <div class="box wow animate__fadeInRight"></div>
    <div class="box wow animate__fadeInLeft"></div>
</body>
<script src="./wow.min.js"></script>
<script type="text/javascript">
    new WOW({
        boxClass: "wow", // 元素可以滚动出现的类名
        animateClass: "animate__animated", // 动画时长的类名，4.xx版本为 animate__animated
        offset: 0 // 当元素与可视区域底部距离多少,开始执行动画
    }).init();
</script>
```
3. 通过添加自定义属性控制元素
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>data-wow-duration</td>
<td>设置出场动画的时长</td>
</tr>
<tr>
<td>data-wow-delay</td>
<td>设置出场动画的延时</td>
</tr>
<tr>
<td>data-wow-offset</td>
<td>设置与浏览器视口底部的距离，达到即出现出场动画</td>
</tr>
<tr>
<td>data-wow-iteration</td>
<td>出场动画的次数</td>
</tr>
</tbody></table>

### bootstrap
有很多自定义的按钮和栅格化布局
## canvas
1. 使用的前置工作
```
<canvas width="500px" height="500px" class="canvas"></canvas> //宽高不宜用css定义
    <script>
        let canvas = document.querySelector(".canvas");
        let ctx = canvas.getContext("2d");
    </script>
```
2. 绘制直线
```
function drawnLine(x1, y1, x2, y2, color) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }
```
*注*：虚线的话需要添加ctx.setDash([5,6]) 。5表示虚线的长度，6表示每段虚线之间的间隔。
3. 绘制圆
```
  function drawnCircle(x, y, r, color) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, false); //false会顺时针，true为逆时针
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
        }
```
4. 绘制矩形
```
    ctx.beginPath();
    ctx.fillRect(x, y, width, height)
    ctx.fillStyle = "red";
    ctx.fill();
    ctx.closePath();
```
5. 绘制文本
```
function drawnText(text) {
            ctx.beginPath();
            ctx.fillStyle = this.color;
            ctx.font = "20px 'Microsoft Yahei'";
            ctx.fillText(text, x, y, 50); //50为文字的最大宽度，若超出则自动压缩
            ctx.closePath();
        }
```
6. 绘制图片
`context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);`
sx,sy,swidth,sheight均为裁剪图片的相关设置，可选。
7. `ctx.translate(x,y)`移动坐标的参照点
8. 清除内容`ctx.clearRect(x, y, width, hegiht)`
## AJAX(Asynchronous JavaScript And XML)
### 概念与流程
1. AJAX是一种实现无页面刷新获取服务器数据的混合技术。它不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。它可以在不重新加载页面的情况下发送请求给服务器。接受并使用从服务器发来的数据。
2. 流程
```
// 创建实例
var xhr = new XMLHttpRequest();
// 设定返回值类型
xhr.responseType = "json";
// 监听请求进度
xhr.onreadyStateChange = function(){
    // readyState == 4 说明请求过程已完成
    // status == 200 说明http请求内容成功，数据可用
    if(xhr.readyState == 4 && xhr.status == 200){
        console.log(xhr.response);
    }
}
// 设置请求方式及地址，地址后面可以跟查询参数，默认为异步请求，最后的true可以省略
xhr.open("GET", "http://bufantec.com/api/douban/movie/in_theaters", true);
// 发送请求
xhr.send(null);
```
3. 基础API
    * readyState：表示请求过程的状态码。0 请求还未初始化；1 已建立服务器链接；2 请求已接受；3 正在处理请求；4 请求已完成并且响应已准备好；
    * status：响应的HTTP状态码。如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常；
    * statusText：HTTP状态码的语言描述
    * responseType：定义响应类型。通常为"json"
    * response：响应体
    * onreadystatechange：监听 readyState 属性变化的事件
    * open()：初始化一个请求。该方法只能在 JavaScript 代码中使用，参数：请求方式，请求URL地址和是否为异步请求的布尔值，默认为异步请求（同步已经被淘汰）
    * setRequestHeader()：设置请求头内容。必须在 open() 之后、send() 之前调用，下面是部分头部信息介绍
        * Accept：浏览器能够处理的内容类型；
        * Accept-Charset: 浏览器能够显示的字符集；
        * Accept-Encoding：浏览器能够处理的压缩编码；
        * Accept-Language：浏览器当前设置的语言；
        * Connection：浏览器与服务器之间连接的类型；
        * Cookie：当前页面设置的任何Cookie；
        * Host：发出请求的页面所在的域；
        * Referer：发出请求的页面URI；
        * User-Agent：浏览器的用户代理字符串；
        * content-type： 数据发送出去后，需要接收的服务端解析成功，一般服务端会根据此字段来获取参数是怎么编码的，然后对应去解码，一般认为content-type有以下四种类型：
            * text/plain AJAX请求的默认值
            * application/json 目前支持率比较高的编码方式
            * application/x-www-form-urlencoded form表单数据的提交编码设置
            * multipart/form-data 二进制文件的编码方式 ( 常用来提交图片或者文件等 )
    * send()：发送AJAX请求，参数为请求体。==注：GET方式没有请求体，一般设置为null。
    * abort()：取消请求
    * getResponseHeader(): 获得响应头部信息
    * getAllResponseHeaders()：获得响应头信息的长字符串
### AJAX的post请求
1. POST请求主要用于向服务器发送应该被保存的数据，以表单登录为例：
```
<form action="http://bufantec.com/api/test/user/doLogin" method="POST">
    <input type="text" name="username" class="uname">
    <input type="password" name="password" class="pwd">
    <button>登录</button>
</form>
```
用AJAX实现如下：
```
var xhr = new XMLHttpRequest();
xhr.responseType = "json";
xhr.onreadystatechange = function (){
    if(xhr.readyState == 4 && xhr.status == 200){
        console.log(xhr.response);
    }
}
xhr.open("POST", "http://bufantec.com/api/test/user/doLogin");
xhr.setRequestHeader("content-type", "application/x-www-form-urlencoded");
xhr.send("username=libai&password=123456");
```
*注*：如果content-type是json数据，则需要写xhr.send(JSON.stringfy("username=libai&password=123456"));
*注*：某些时候如果数据总是请求失败，可以尝试将content-type改为Content-Type
2. form中get与post的差异：
    * get请求参数在地址栏显示，post不会，相对来说更安全
    * 地址栏理论上来说有长度限制，get的参数长度会受到限制，而post不会
    * get请求没有请求体，get的参数类型为字符串，post可以发送不限类型的参数
    * post因为参数类型有区别，需要设置请求头content-type来指定参数类型，而get则不需要指定
### AJAX的新规范
1. 超时设定
```
// 当响应时间超过1秒时，请求中止，弹出提示框
xhr.timeout = 1000
xhr.ontimeout = function() { alert("Request did not return in a second.") }
```
*注*：当请求终止时，会调用 ontimeout 事件处理程序，此时 xhr 的 readyState 属性的值可能已变为4，这意味着会继续调用 onreadystatechange 事件处理程序。
2. 事件进度。该规范定义了与客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以更细的颗粒度掌控数据传输过程中的细节。目前共有6个进度事件，他们会随数据传输进展被顺序触发（除了error，abort事件）
    * loadstart：在接收到响应数据的第一个字节时触发
    * progress：在接收响应期间持续不断地触发；该事件可以实现加载进度条效果。因为onprogress事件处理程序会接收到一个event对象，其target属性为XHR对象实例，但却额外包含着三个属性：
        * lengthComputable：表示进度信息是否可用的布尔值
        * loaded：表示目前接收的字节数
        * total：表示根据Content-Length响应头部确定的预期字节数
        ```
        xhr.onprogress=function(){
            if(event.lengthComputable)
            {
                console.log("已加载字节",event.loaded);
                console.log("已加载字节",event.total);
            }
        }
        ```
        *注*：数据类型无法计算，一般用于计算图片的进度
    * error：在请求发生错误时触发；
    * abort：在调用 abort() 方法时触发，取消请求，但是既不会触发load事件，也不会触发error事件，会触发loadend事件；
    * load：在接收到完整的响应数据时触发，该事件帮助我们节省了readystatechange事件
    * loadend：在通信完成或者触发error，abort，或load事件后触发；
### AJAX封装
```
function ajax(params){
    if(!params.url){
        alert("请务必传入请求地址");
        return;
    }
    // 赋值默认参
    params = Object.assign({
        type: "GET",
        data: null,
        contentType: "application/x-www-form-urlencoded", // post请求时定义参数类型
        header: {}, // 与后台协定的头部信息
        dataType: "json", // 返回值类型
        success(){},
        fail(){},
    }, params);
    // 声明核心对象
    var xhr = new XMLHttpRequest();
    // 赋值返回值类型
    xhr.responseType = params.dataType;
    // 请求过程结束监听
    xhr.onload = function (){
        switch(xhr.status){
            case 200:
                params.success(xhr.response);
                break;
            case 400:
                params.fail(xhr.statusText, "参数错误");
                break;
            case 404: 
                params.fail(xhr.statusText, "URL信息错误");
                break;
            case 500:
                params.fail(xhr.statusText, "服务器内部错误");
                break;
            default:
                break;
        }
    }
    // 请求意外情况
    xhr.onerror = params.fail;
    // 请求过程的函数  onprogress
    // 参数序列化  qs.js
    var str = "";
    for(var i in params.data){
        // i => key params.data[i]  value   key:value => key=value&
        str += `&${i}=${params.data[i]}`;
    }
    // & name=value&name=value...
    str = str.slice(1);
    // 发送请求前做
    params.beforeSend && params.beforeSend();
    // 定义请求类型以及地址
    if(params.type.toUpperCase() == "GET"){
        xhr.open("GET", params.url + (params.data ? "?" + str : ""));
        // 发送请求
        xhr.send(null);
    }else {
        xhr.open("POST", params.url);
        xhr.setRequestHeader("Content-Type", params.contentType);
        for(var j in params.header){
            xhr.setRequestHeader(j, params.header[j]);
        }
        // 发送请求
        if(/json/.test(params.contentType)){
            xhr.send(JSON.stringify(params.data));
        }else if(/form/.test(params.contentType)){
            xhr.send(str);
        }
        else{
            xhr.send(params.data);
        }
    }
}
```
### jQuery中的AJAX
1. 示例。所有的选项都可以通过 $.ajaxSetup() 函数来全局设置
```
$.ajax({
    url: "./test.json",
    method: "get", // 默认，可以不写
    success: function (res){
        console.log(res); // 成功后返回的文本
    },
    fail: function (err){
        console.log(err); // 失败后返回的原因
    }
})

// 换成 get 方法
$.get("./test.json", function (data,textstatus){
    console.log(res);
})
```
2. `$.get() $.post()`，它们分别是get和post方法的简化版，结构：`$.get(url,[data],[callback],[type])`带中括号的参数可以省略，两个方法的结构一致，回调函数 callback 有两个参数：data 代表返回的内容；textstatus 代表请求状态，其值可能是success、error、notmodify、timeout其中一种。
## JS同步与异步
1. JS代码运行：JavaScript 本身是单线程的，即它在同一个时间只能做一件事。所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果某一段 JS 执行的时间过长，这样就会造成后面的代码执行不连贯，导致页面渲染加载阻塞的感觉。
为了解决这个问题，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。
2. JS 在执行代码时，会按照代码的书写顺序，将每一句代码压入调用堆栈中执行，如果遇到异步代码，它们会被添加到浏览器提供的异步线程中，等到它们的触发条件满足，被压入任务队列等候执行。当页面代码执行完毕，事件轮循（event-loop）就会按次序读取任务队列中等候执行的异步任务，将它们推入调用堆栈（call stack）中执行。
    * 调用堆栈(call stack)：一个具有LIFO(后进先出)结构的堆栈，用于存储在代码执行期间创建的所有执行上下文。每一条或一块语句执行之前，都会被加入到执行栈中，执行语句前创建执行栈，然后把语句加入，执行完成后就销毁该执行栈。
    * 事件轮询(event loop)：的工作是监听调用堆栈，并确定调用堆栈是否为空。如果调用堆栈是空的，它将检查消息队列，看看是否有任何挂起的回调等待执行
3. 同步任务：一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。
4. 异步任务：
    * 1，DOM事件：如 click、resize 等
    * 2，资源加载：如 load、error 等
    * 3，定时器：包括 setInterval、setTimeout 等
    * 4，网络资源请求：Ajax、Fetch 等
## 跨域
### document+domain
前提：只有在主域相同的时候才能使用该方法
实现：两个页面都通过JS设置 document.domain 为主域，实现同域
```
// 在www.a.com/a.html中：
document.domain = 'a.com';
var ifr = document.createElement('iframe');
ifr.src = 'http://www.script.a.com/b.html';
ifr.display = "none";
document.body.appendChild(ifr);
ifr.onload = function(){
    var doc = ifr.contentDocument || ifr.contentWindow.document;
    //在这里操作doc，也就是b.html
    ifr.onload = null;
};
// 在www.script.a.com/b.html中：
document.domain = 'a.com';
```
### postMessage
语法：`otherWindow.postMessage(message, targetOrigin, [transfer]);`
message：将要发送到其它页面的内容
targetOrigin：指定那些页面能够接受到消息
transfer：可选，转移传递对象的所有权，一般不写
```
<!-- a.html -->
<iframe src="http://localhost:4000/b.html" id="ifr" onload="load()">
</iframe>
<script>
    function load(){
        var ifr = document.querySelector("#ifr");
        ifr.contentWindow.postMessage("hello I'm a.html! Can you see this?", "http://localhost:4000");
        window.onmessage = function(e){ // 本页面接收数据
            console.log(e.data);
        }
    }
</script>

<!-- b.html -->
<script>
    window.onmessage = function(e){
        console.log(e.data); // 接收到的数据
        e.source.postMessage("I can！How did you do that？",e.origin);
    }
</script>
```
### jsonP
1. 原理：动态创建script标签，然后利用script的 src 不受同源策略约束来跨域获取数据。JSONP请求一定需要对方的服务器做支持才可以。
缺点：只支持get方式请求
```
// 原生js写法
var script = document.createElement('script');
script.type = 'text/javascript';
// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
script.src = 'http://www.domain2.com:8080/login?user=admin&callback=jsonPCallback';
document.body.appendChild(script);
// 前端回调执行函数
function jsonPCallback(res) {
    alert(JSON.stringify(res));
}
//服务端返回如下（后端返回执行函数）：
jsonPCallback({"status": true, "user": "admin"})
// jq写法
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});
```
### CORS
ORS 作为现在的主流解决方案，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 Ajax 只能同源使用的限制。实现 CORS 通信的关键是服务器，只要服务端实现了 CORS 接口，就可以进行跨源通信。
CORS需要浏览器和服务器同时支持。
```
router.get("/", function(req,res,next){
    // 设置允许访问的头为：*  即任何地址都可访问
    res.header('Access-Control-Allow-Origin', '*');
    // Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行
    // res.header('Access-Control-Allow-Headers', 'Content-Type');
    // res.header('Access-Control-Allow-Methods', '*');
    // res.header('Content-Type', 'application/json;charset=utf-8');
    next();
})
```
*注*：JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
## 文件上传
1. files属性。是input元素的一个属性，记录着上传的文件，是一个伪数组
2. FileReader 读取文件 —— 展示在页面上 异步过程 
```
ipt.onchange = function (){
      // 文件选择input元素，具有 files 属性，是一个文件伪数组
      console.log(this.files);
      // for(var i = 0 ; i< this.files.length; i ++){
      //   console.log(this.files[i]);
      // }
    let file = this.files[0];
      var fileReader = new FileReader();
      // 设置过程监听
      fileReader.onload = function (){
        // console.log("读取结果 base64字符串", this.result);
        document.querySelector(".box").innerHTML = `<img src="${this.result}"><p>${file.name} ${Math.ceil(file.size/1024)}KB</p>`; //this.result相当于记录了文件的路径
      }
      fileReader.onprogress = function (e){
        if(e.lengthComputable){
          console.log("读取过程 进度为：", e.loaded / e.total * 100 + "%");
        }else {
          console.log("进程无法监听");
        }
      }
      fileReader.onerror = function (e){
        console.log("读取失败，事件对象为", e);
      }
      // 读成什么样的值
      fileReader.readAsDataURL(file);
    }
```
3. FormData 在用ajax上传文件之前必须先生成FormData，在以FormData作为参数
```
let formData = new FormData();
                formData.append("file", file);//键值对形式，第一个file指的是属性名，可以改为其他名字，第二个file是变量，是指上传的文件，file=input对象.files[0]
                $.ajax({
                    url: "http://www.bufantec.com/api/test/user/upload",
                    type: "post",
                    data: formData,
                    contentType: false,
                    processData: false,
                    success: function (res) {
                        console.log(res.code);
                        render();
                    }
                })
```
4. 文件拖拽上传
主要借助event.dataTransfer.files实现文件属性的传递
```
$(".box").on("dragover", function () {
            event.preventDefault();
        })
        $(".box").on("drop", function () {
            event.preventDefault();
            console.log(event.dataTransfer.files[0]);
            for (let i = 0; i < event.dataTransfer.files.length; i++) {
                let file = event.dataTransfer.files[i];
                let imgUrl = URL.createObjectURL(file);
                $(".box").append(`<img src=${imgUrl} onload="remove()">`);
            }
        })
        //图片加载完成后销毁url实例，节省内存
        function remove() {
            URL.revokeObjectURL(event.target.src);
        }
```
## websocket
1. HTTP是单向链接协议，只能由客户端发起，服务端被动响应；服务端不具备向客户端主动发送消息
    WebSocket 是双向链接协议，由客户端发起建立链接，然后服务端可以与客户端在线通讯
      可以实现  K线图、聊天室
      心跳检测 —— 检测当前链接是否中断
2. 
```
let ws = new WebSocket("ws://localhost:8080");
ws.onopen = function() {
  console.log("client：打开连接");
  ws.send("client：hello，服务端");
};
ws.onmessage = function(res) {
  console.log("client：接收到服务端的消息 " + res.data);
  setTimeout(() => {
    ws.close();
  }, 5000);
};
ws.onclose = function(params) {
  console.log("client：关闭连接");
};
```
3. WebSocket对象的readyState属性，用来表示对象实例当前所处的链接状态，有四个值：
0：表示正在连接中（CONNECTING）；
1：表示连接成功，可以通信（OPEN）；
2：表示连接正在关闭（CLOSING）；
3：表示连接已经关闭或打开连接失败（CLOSED）；
4. WebSocket对象的事件属性
    * onopen：用于指定连接成功后的回调函数；
    * onclose：用于指定连接关闭后的回调函数；
    * onmessage：用于指定收到服务器数据后的回调函数，通过形参.data获取到返回的数据 ；
    * onerror：用于指定报错时的回调函数；
5. 通过.send()方法，向服务器发送数据
`ws.send(JSON.stringify({ userId: uid, msg: "hello everyOne, I'm King of this class" }));`
## es6新增
1. symbol 表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）
```
<script>
    var s1 = Symbol();
    var s2 = Symbol();
    console.log(s1 === s2); // false
    //也可在括号里添加描述信息
    var s1 = Symbol("我是s1的描述");  //  作用是方便理解这个定义的值是做什么用处
    var s2 = Symbol("我是s2的描述");
    console.log(s1 === s2); // false
    console.log(s1.description); // 可借助description属性获取描述信息
</script>
```
2. class类：类抽象了对象的公共部分(封装了公共的属性和方法)，他泛指某一大类(class)，
对象特指某一个，通过类实例化一个具体的对象
他俩之间的关系可以理解为设计图(类)和实物(对象)的关系    
```
 class Animal{
            constructor(name,age) {
                this.name=name;
                this.age=age;
            }
            eat(){
                console.log("eating.....")
            }
              //静态方法
            static happy(){
                console.log("happy.....")
            }
            //固有属性（必须被子类继承的属性）
            hobby="reading"
        }
        //实例
        var a1=new Animal("dog",2);
        console.log(a1);
        a1.eat();
        Animate.happy();静态方法必须使用类去调用
```
*注*；类的注意事项：首字母大写；函数不能加function；不加逗号；类的所有方法都是定义在原型上
3. 类的继承。Class 可以通过extends关键字实现继承。A类继承了B这个类, A叫做子类, B叫做基类
```
class Bird extends Animal{
        constructor(name,age,color,cicle) {
            super ();//必须在第一行调用super改变this值为子类
            this.name = name;
            this.age = age;
            this.color=color;
            this.cicle = cicle;
        }
        play(){
            console.log('飞到天上玩.....')
        }
        //静态方法
      static fly(){
            console.log('我要飞的更高。。。。')
        }
    }
```
4. proxy 在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截
```
var proxy = new Proxy(target, handler);
var film={
        title:'穿过寒冬拥抱你',
        price:45
    }
    var proxy=new Proxy(film,{
        get(target,attr){
            console.log("get触发了");
            //定制返回值 如果查找不到当前的值,返回error
            if(attr in target){
                return target[attr];
            }else{
                throw new Error(`你当前访问的属性${attr}不存在`)
            }
        },
        set(target,attr,value){
            console.log("set触发了");
            //定制设置的属性,如果设置的值超过了最大返回,返回error
            if(attr=='price'){
                if(value>300){
                    throw new Error("你设置的属性值超过了最大范围")
                }else {
                    return target[attr];
                }
            }else{
                return target[attr];
            }
        },
        })
    console.log(proxy.title);//要使用proxy才能触发上面的函数
```
5. 模板自变量标签函数
```
let a = 6;
        let b = 9;
        function test(strings, a, b, c) {
            console.log(strings);// ["", "+", "=", ""]
            console.log(a);//6
            console.log(b);//9
            console.log(c);//15
            return "ok";
        }
        let testis = test`${a}+${b}=${a + b}`;
        console.log(testis);
```
6. try catch
```
    try {
​    console.log(rand())
​    } catch (error) {
​    console.log(error)
​    }
//首先，执行 try {...} 里面的代码。
如果执行过程中没有异常，那么忽略 catch(err) 里面的代码，try 里面的代码执行完之后跳出该代码块。
如果执行过程中发生异常，控制流就到了 catch(err) 的开头。变量 err（可以取其他任何的名称）是一个包含了异常信息的对象。
```
7. 变量结构赋值
```
let [foo, bar, baz] = [1, 2, 3];
var {egg,bread,fruit}={bread:"早餐面包",fruit:"apple",egg:"鸡蛋"};
```
8. Promise
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
```
    var p=new Promise((resolve,reject)=>{
        setTimeout(()=>{
            var num=Math.ceil(Math.random()*10);
            if(num>5){
                  resolve(num);//这是之后要在then中处理的num
            }else{
                 reject(num);//这是之后要在then中处理的num
            }
        },500)
    })
    //用then方法分别指定resolved状态和rejected状态的回调函数。
     p.then(function(res){
         console.log("res",res);
     },function(err){
         console.log("err",err);
     })
     //推荐这样写
    p.then(res=>{
        console.log("res",res);
    }).catch(err=>{
        console.log("err",err);
    })
```
9. async await
async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
async await 最大的好处是让前端有了能力 以同步的方式写异步的代码
```
//async await 重构ajax
function getUser(){
        return $.ajax({
            url:'http://bufantec.com/api/test/user/list?start=10'
        })
    }
  function getuserInfo(val){
      return  $.ajax({
            url:`http://bufantec.com/api/test/user/detail?id=${val}`
        })
  } 
async    function getResult(){
      const result1 = await getUser();
      const result2 = await getuserInfo(result1.data.list[1].userId);
      console.log(result2);
  } 
   getResult()
```
# js 其他内容
1. *面试*：防抖与节流
防抖 – 在一定时间内触发事件就执行一次定义好的行为，如果在这段时间内再次触发事件，则时间重新计算，且不执行定义好的行为。
节流 – 在一定时间内触发事件就执行一次定义好的行为，如果在这段时间内再次触发事件，不重新计算时间，且不执行定义好的行为
二者的区别在于防抖每次触发时重新计时，而节流每次触发时忽略该动作，原来的计时照常进行。
防抖与节流均有立即执行一次版，和非立即执行版。
2. 防抖(debounce)
```
<div class="box">1</div>
    <script>
        let box = document.querySelector(".box");
        box.onclick = (() => {
            let timer = null;
            return () => {
                if (timer) { clearTimeout(timer) }
                timer = setTimeout(() => {
                    box.innerText = +box.innerText + 1;
                    timer = null;
                }, 1000)
            };
        })(); //将return中的函数绑定为click事件，借助闭包访问timer
    </script>
```
3. 节流(throttle)
法一：
```
<div class="box">1</div>
    <script>
        let box = document.querySelector(".box");
        box.onmousemove = (() => {
            let timer = null;
            return () => {
                if (!timer) {
                    timer = setTimeout(() => {
                        box.innerText = +box.innerText + 1;
                        clearTimeout(timer)
                        timer = null;
                    }, 1000);
                }

            };
        })(); 
    </script>
```
法二：
```
<div class="box">1</div>
    <script>
        let box = document.querySelector(".box");
        box.onmousemove = (() => {
            let startTime = Date.now();
            return () => {
                let nowTime = Date.now();
                if (nowTime - startTime >= 1000) {
                    box.innerText = +box.innerText + 1;
                    startTime = nowTime;
                }
            };
        })(); 
    </script>
```
# vue
*坑*：
1. vue对两种数据没有响应式：1.对象后来添加的属性；2.数组中通过下标添加的属性
*注*：解决方法`Vue.set(vm.obj,'sex','男')`或`vm.$set(vm.obj,'sex','男')`
*杂谈*：
1. 挂载到原型后，不需Vue.use(),不然会使用两遍
2. vue对undefined值不会显示在页面上
2. vant组件toast需要用Vue.use(toast)
## vue指令
1. 数据绑定指令
    * v-text 操作文本，会整体替换标签内的文本。可使用简写模式{{}}避免此缺点
    * v-html 操作html文本
    * v-model 用于表单元素的双向绑定。可添加修饰符，.lazy用户在输入完成后再同步值；.number将输入的值转为数字类型；.trim去掉输入文本前后的空格
```
<div id="app">
    <div v-text="name"></div>
    {{name}}
</div>
<script>
    var vm = new Vue({
        el : "#app", // 需要挂载到某个元素上
        data(){ // 数据仓库
            return {
                name : "皮皮鲁与鲁西西之罐头小人"
            }
        }
    })
</script>
```
```
<label>男</label><input type="radio"  value="男"  v-model="sex"   />
<label>女</label><input type="radio"  value="女"   v-model="sex"   />    
<label>其他</label><input type="radio" value="其他" v-model="sex"   />    
<p>你的性别是：{{sex}}</p>

<script>
        var vm=new Vue({
            el:'#app',
            data:{
                sex:'男',
            }
        })
</script>
```
```
<div id="demo">
        <input type="checkbox" value="睡觉" v-model="hobit"> 睡觉
        <input type="checkbox" value="游泳" v-model="hobit"> 游泳
        <h3>你的爱好是:{{hobby}}</h3>
</div>
<script type="text/javascript">
    var app=new Vue({
        el:'#demo',
        data:{
            hobby: []
        }
    });
</script>
```
```
<div id="demo">
    <select v-model="level">
            <option value="黑铁">黑铁</option>
            <option value="青铜">青铜</option>
        </select>
      <h3>当前的段位是:{{level}}</h3>
</div>
<script type="text/javascript">
    var app=new Vue({
        el:'#demo',
        data:{
             level: "青铜"
        }
    });
</script>
```
2. 属性指令
v-bind用于绑定标签中经常变化的属性，比如图片的src以及链接的src，可简写为":"
```
  <h2 v-bind:title="title">
      我是标签
  </h2>
<a v-bind:href="target">京东一下</a>
  <script>
    var vm = new Vue({
      el: "#app",
      data() {
        return {
          title:"标签",
          target:'http://www.jd.com',
        };
    }})
  </script>
```
3. 条件指令 v-if、 v-show
*注*：都是控制元素的现实与隐藏，区别在于v-show是通过display来控制的，隐藏后标签还在，但是v-if则是通过dom直接删除元素，在html中不会显示出标签。且v-if还可以控制组件的隐藏(可配合template使用），而v-show不能用于大篇幅列表的隐藏
```
<div id="app">
    //使用v-if, v-else-if时必须是紧挨着的兄弟元素
    <div v-if="age>30">
        {{ name1 }}
    </div>
    <div v-else-if="age == 30">
        {{ name2 }}
    </div>
    <div v-else>
        {{ name3 }}
    </div>
</div>
<script>
  var vm = new Vue({
    el: "#app",
    data() {
      return {
        name1: "王五",
        name2: "李四",
        name3:"张三",
        age: 30,
      };
    }
  });
</script>
```
4. 循环指令v-for
```
<div id="app">
    <p v-for="(item,index) in books" :key="index">{{index+1}}---{{item}}</p>
</div>
var vm=new Vue({
     el:'#app',
     data:{books:["三国演义","红楼梦","西游记"]},
})
//此处key会报错，一般是用唯一的id作为key
//其实也可以遍历对象和字符串和指定次数，但是用的少
```
5. 自定义指令
指令会在一下情况调用：1.指令第一次与元素绑定时；2.元素所在模板重新渲染时
*注*：自定义指令名不要用驼峰命名法，用短线连接
*注*：自定义指令中的this为window
​ 指令定义函数提供了几个钩子函数：
​ 1.bind 只调用一次，指令第一次绑定到元素时调用 在这里可以进行一次性的初始化设置 （一般进行样式之类的操作）
​ 2.inserted 被绑定元素插入父节点时调用 (一般进行js相关的操作)
​ 3.update 所在组件的Vnode更新时调用，但是可能发生在其子元素的Vnode更新之前
​ 4.componentUpdate 所在组件的Vnode及其子元素的Vnode全部更新时调用
​ 5.unbind 只调用一次，指令与元素解绑时
```
 <p id="app" v-color>颜色</p>
    <script>
        Vue.directive("color", {
            bind(el, binding) {
                el.style.color = "red";
            }
        })
        //binding是一个对象，包含v-color.a.b:top="current"这种形式的自定义指令中的各项值
        //name:"color"; value:"current在data中的值";  oldvalue:"绑定的上一个值"; expression:"current"; arg:"top"; modefiers:{'a':true,'b':true}
        new Vue({
            el: "#app",
            data() {
                return {

                }
            }
        })
    </script>
```
6. v-cloak， v-once和v-prev
v-cloak在vue接管元素后会删除，主要用于解决js代码没加载出来页面就显示内容的问题；
v-once让动态渲染的东西只执行一次；
v-prev让vue跳过当前元素的解析，即不会解析插值语法等，完全当作原生html
## vue属性和方法
1. class与style绑定
    * 三元运算符实现
    `<li v-for="item in todos" :key="item.id" :class="item.done?'active':''">`
    * 数组语法`<li :class="[item.done?'active':'',item.done?'':'current']">`
    * 对象语法
    ```
    <div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }>"
    //vue的 class和原有的class不冲突。此处是如果变量isActive的值为true，则添加active类名
    ```
    * 行内样式
    ```
    <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
    <div v-bind:style="styleObject"></div>
    <script>
    var vm = new Vue({
        el: "#app",
        data(){
            return {
                activeColor: 'red',
                fontSize: 30,
                styleObject: {
                    color: 'red',
                    fontSize: '13px'
                }
            }
        }
    });
    </script>
    ```
2. 事件
```
 <button v-on:click="counter += 1">Add 1</button> 
 //可直接在行内书写代码，也可在vue的methods中定义函数
<button v-on:click="add($event)">Add 1</button>
//如果给组件绑定click则会被当成自定义事件，可以加修饰符@click.native
var example1 = new Vue({
  el: '#example-1',
  data: {
    counter: 0
  },
  methods:{
      add(e){
          this.counter ++ ;
          e.preventDefault();
          e.stopPropogation();
          e.cancelBubble();
      }
  }
})
//$event为vue的事件对象的占位符。若绑定事件时没写括号，则add也默认有一个形参代表事件对象。 v-on可简写为@，比如@wheel,@scroll
//绑定事件的另一种方法this.$refs.test.$on('事件名',callback)，此时callback函数中的this指向ref，如果是箭头函数则例外
//解绑事件this.$refs.test.$off('事件名')或是['事件1','事件2']，不传参默认解绑全部
```
3. 事件修饰符
    * .stop阻止事件冒泡
    * .prevent阻止默认事件
    * .self 使用self实现点击当前    元素的时候才触发事件处理函数 可以理解为变相的阻止事件冒泡
    * .capture 实现事件捕获机制 默认事件触发从里到外 capture实现事件触发从外到里
    * .once 事件只触发一次
    * .passive事件的默认行为立即执行，无需等待回调函数执行完毕。主要用于@wheel事件（不需要函数执行完，先执行滚动条滚动，用于优化性能）
    * .native用于给组件绑定原生dom事件时避免被vue当成自定义事件
```
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>
<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>
<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>
//键盘事件修饰符
 <!-- 回车 13 -->
    <input type="text" value="按钮" @keyup.13="show()"/>
    <input type="text" value="按钮" @keyup.enter="show()"/>
    <input type="text" value="按钮" @keyup.up="show()"/>
    <input type="text" value="按钮" @keyup.down="show()"/>
    <input type="text" value="按钮" @keyup.left="show()"/>
    <input type="text" value="按钮" @keyup.right="show()"/>
    //其他的别名还有esc,delete（包括退格和删除）,space,tab
    //系统修饰键，ctrl,meta,shift,alt必须配合其他按键使用,如@keyup.ctrl.s实现ctrl+s保存
```
事件修饰符也可以连写
4. 计算属性computed
当其依赖的属性的值发生变化时，计算属性会重新计算，反之，则使用缓存中的属性值。
```
 computed: {
                allChecked: {
                    get() {
                        return this.goods.every(item => item.isBuy)
                    },
                    set() {
                        let checked = this.allChecked;
                        this.goods.forEach(item => item.isBuy = !checked)
                    }
                },
                //如果该属性只有get，没有set则可简写为下列形式
                amount() {
                    return this.goods.reduce((prev, next) => !next.isBuy ? prev : (prev + next.num * next.price), 0)
                }
            }
```
5. filter(vue3已移除)
可用于插值语法和v-bind
```
<h3>{{new Date()|filteTime(2)}}</h3>//函数的第一个参数默认为管道符号前面的的变量
//全局过滤器
    Vue.filter("filteTime", function (time, n) {
          const yy = time.getFullYear();
          const mm = (time.getMonth() + 1 + "").padStart(n, 0);
          const dd = (time.getDate() + "").padStart(n, 0);
          const hh = (time.getHours() + "").padStart(n, 0);
          const ff = (time.getMinutes() + "").padStart(n, 0);
          const ss = (time.getSeconds() + "").padStart(n, 0);
          return `${yy}-${mm}-${dd}  ${hh}:${ff}:${ss}`
        })
//局部过滤器
var vm = new Vue({
            el: "#app",
            data() {
               
            },
            filters: {
                capitalize: function (value) {
                if (!value) return ''
                value = value.toString()
                return value.charAt(0).toUpperCase() + value.slice(1)
            }
            }
            
        })
```
6. watch 监听数据变化，与computed相比其优点在于可以执行异步操作或高性能的操作，还可以监听路由的变化。也可以监听计算属性
```
<div id="app">
    <input type="text" v-model="num">
</div>
    new Vue({
        el: '#app',
        data: {
            num: ''
        },
        watch: {
            num(newVal, oldVal) {
            // 监听 num 属性的数据变化
            // 作用 : 只要 num 的值发生变化,这个方法就会被调用
            // 第一个参数 : 新值
            // 第二个参数 : 旧值,之前的值
                console.log('oldVal:',oldVal)
                console.log('newVal:',newVal)
            }
        }
    })
    //watch中可添加immediate和deep两个属性
     watch: {
            num: {
                // 数据发生变化就会调用这个函数  
                handler(newVal, oldVal) {
                    console.log('oldVal:', oldVal)
                    console.log('newVal:', newVal)
                },
                // 立即处理 进入页面就触发
                immediate: true,
                // 深度监听 属性的变化,用于监听对象
                deep: true
            }
            //监听对象数据类型的另外一种方法
            'food.name'(newVal, oldVal) {
                console.log('oldVal:', oldVal)   // 冰激凌
                console.log('newVal:', newVal)   // 棒棒糖
            }
        }
    //也可写成如下形式vm.$watch('num',{handler(){}})
    //监听路由变化
    watch: {
    $route(to, from) {
      let routeArr = ["home", "subject", "kinds", "cart", "user"];
      if (!routeArr.includes(to.name)) {
        this.isshow = false;
      } else {
        this.isshow = true;
      }
    },
  },
```
7. 生命周期钩子函数
    * beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性
    * created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板(模板 比如{{}})
    * beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中
    * mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示
    * beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点
    * updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！
    * beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。可以访问实力所有的数据及方法，但是页面不会更新数据。一般用来解绑$bus事件
    * destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例,绑定的自定义事件也会被销毁。
    * nextTick 在下次 DOM 更新循环结束之后执行延迟回调。`this.$nextTick(function(){})`可用于在created钩子函数中操作dom
    * actived 路由组件激活时（路由组件独有）。主要用于组件被`<keep-alive>`时代替created使用
    * deactived 路由组件失去激活时（路由组件独有）
```
  const vm = new Vue({
            el: '#root',
            data: {
                test: '天王盖地虎'
            },
            created() {
                console.log('created钩子事件：');
                console.log(this.$data);
                console.log(this.$el);
            }
        })
```
8. nextTick 
在下次 DOM 更新循环结束之后执行延迟回调。`this.$nextTick(function(){})`
9. ref
```
<p ref="p">hello</p>
//可在vue的$refs属性中找到p并执行相关的dom操作
```
## vue-cli与vue组件与模块化
1. 安装vue-cli
    * 下载并安装Node.js,http://nodejs.cn/download/ 安装完成后命令框node -v查看版本号
    * 卸载旧版本1.x,2.x,命令npm uninstall vue-cli -g 
    * 安装 npm install -g @vue/cli,输入vue -V查看版本号
2. 插件的安装
分为本地安装（只对当前文件夹生效）和全局安装，本地安装又分为--save-dev和--save,前者会出现在package.json文件中的devDependencies，后者出现在dependencies，devDependencies中一般是系统的插件，很少安装，通常使用--save-dev安装在dependencies中
安装npm install jquery --save-dev
卸载npm uninstall jquery
3. 创建项目
    * vue create 项目名（尽量使用中划线，不要驼峰命名）
    * vue create ui
4. 组件的使用
```
//先定义一个组件vue文件或者直接在父组件的components定义
import Test from "./components/test.vue";//引入，这个test名字可以随便起，与components中对应即可。一般使用大驼峰
export default {
  name: "App",
  components: {
    test: Test,//Test与上面随便起的名字对应
  },
  data() {
    return {
      value: "14",
    };
  },
};
<test></test>//使用组件，名字与components中的属性名对应，必须使用中划线转化驼峰命名
```
5. 组件的属性
```
//与之前vue实例中的属性差不多，把el替换为template
 components:{
                "navs":{
                    template:"#navs",
                    data(){
                        return {
                            list:['秒杀','优惠券','PLUS会员','品牌闪购','拍卖','京东家电','京东超市','京东生鲜']
                        }                        
                    },
                    methods:{
                       show(item){
                           console.log(item);
                       }    
                    },
                    computed:{
                        sayhello(){
                            return "nav hello!!"
                        }
                    }
                },
            },            
```
6. *面试*：组件之间的通信
    * 父=>子传递数据
    ```
    //1.父组件中在子组件标签上绑定一个自定义属性，可以绑定多个
    <test :testValue="value"></test>
    //2.子组件中在props属性中声明这个自定义属性
    <h4>父组件的值{{ testValue }}</h4>
    export default {
    name: "exam",
    props: ["testValue"],
    },
    //上面是props的简写，完整写法为
    props:{
        testValue:{
            type:String,//值的类型
            required:true,//是否必需
            default:"hello",//若testValue的值未定义时的默认值
        }
    }
    //子组件正常情况下无法修改父组件传过来的属性，但可以借助sync修饰符
    <test :testValue.sync="value"></test>
    //子组件中定义修改事件
      changeProp(){
                     this.$emit('update:testValue', "改变之后的")
                 }
    ```
    * 子=>父传递数据
    ```
    //方法一
    //子组件借助$emit传递事件，以及参数
      this.$emit("sendvalue", "hello");
    //父组件注册该传递的事件，并读取传递的参数
    <test @sendvalue="logvalue" testValue="value"></test> //可添加事件修饰符
    methods: {
    sendvalue(params) {
      console.log(params);
    },
    //父组件注册事件还有一种方法
    <test ref="test"  testValue="value"></test>
    mounted(){
        this.$refs.test.$on("sendvalue",logvalue)
    }
    //方法二，父组件给子组件传递一个方法，然后在子组件中调用这个方法
    //父
     <test :updateAge="updateAge"></test>
       updateAge(a) {
      console.log(a);
    },
    //子
     <button @click="updateAge(2)">年龄++</button>
       props: ["updateAge"],
    ```
    * 兄弟组件传递数据
    ```
    //main.js中定义$bus（中央事件总线）
    Vue.prototype.$bus = new Vue();
    //子组件传值，另一个接受值的组件的created中监听该事件
     sendToTest() {
      this.$bus.$emit("sendToTest", "你好");
    },
    //接受值的组件的created函数中
     this.$bus.$on("sendToTest", (val) => {
      this.value = val;
    });
    ```
7. *面试*模块化规范的发展：服务器端CommonJS，浏览器端AMD和CMD
8. *面试*模块导入和导出的方式
    1. 按需导入/导出（两个myName必须相同）
    `export let myName="贾玲";import {myName} from "./test.js";`
    2. 默认导出（default export）/ 导入（两个变量名不需要相同）
    `export default function(){  };import myFn from "./test.js";`
    3. 直接导入，如果想把整个js或者css文件直接拿过来使用可以则可以直接导入import  "../a.js"
    *补充*：使用*全部接受，使用as起别名
    ```
    let myName="laowang";
    let myAge=90;
    let myfn=function(){ return "我是"+myName+"！今年"+myAge+"岁了"}
    export {  
    myName as name,   
    myAge as age,  
    myfn as fn}
    import * as info from "./test.js"; 
    ```
## vue动画
1. vue动画(下列情形可添加： v-if v-show 动态组件 组件根节点)
```
<transition name="fade">            
            <div class="box" v-if="show"></div>
</transition>   
<style>
      .box {
                width: 200px;
                height: 200px;
                background: #8A2BE2;
            }
       .v-enter{
            opacity: 0;
        }
        .v-enter-to{
            opacity: 1;
        }
        .v-enter-active{
            transition: all 5s;
        }
           .v-leave{
            opacity: 1;
        }
        .v-leave-to{
            opacity: 0;
        }
        .v-leave-active{
            transition:  all 3s;
        } 
}
<button @click="show=!show">点击显示和隐藏</button> 
```
2. css动画
```
<transition name="bounce">            
            <div class="box" v-if="show"></div>
</transition>   
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-in .5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}
```
## mock模拟数据
1. 官网http://mockjs.com/
2. 安装npm install mockjs,引入import Mock from 'mockjs'
3. 生成随机数据
```
let { list } = Mock.mock({
        "list|10-20": [
          {
            id: "@increment(1)",
            title: "@ctitle()",
            info: "@cparagraph()",
            img: '@dataImage("200x240", "电影图片")',
          },
        ],
      });
```
4. mock拦截ajax
```
 Mock.mock(
     //可使用正则，也可以使用和url完全相同的字符串
      /http:\/\/www.bufantec.com\/api\/douban\/movie\/in_theaters/,
      "get",
      (params) => {
         console.log("success", params);
      }
    );
```
## 动态组件,mixin与插槽
1. 动态组件，让多个组件使用同一个挂载点，并动态切换，这就是动态组件
`<component is="Test"></component>`Test为components属性中组件对应的属性名
2. 插槽，用于替换组件中的相应内容，达到多个相同组件中的某部分展示不同内容的效果
```
//1.匿名插槽
<Test2>test2</Test2>//App.vue中
<slot></slot>//test2.vue中
//2.具名插槽
 <Test>
      <template v-slot:id>test </template>
</Test>
<slot name='id'></slot>
//上述的匿名插槽其实等同于如下具名插槽
<Test2><template v-slot:default>test2 </template></Test2>//App.vue中
<slot name='default'></slot>
//具名插槽可简写
<Test>
      <template #id>test </template>
</Test>
//3.利用插槽传值（子传父）
<Test>
      <template #id="value">{{ value.val }} </template>
      //此value可随意起名字，是一个存储了slot标签上绑定属性:val的值的对象
</Test>
<slot name="id" :val="data.value"></slot>//此value对应data中的相应值，可替换为其他数据
```
3. mixin让不同组件混用共同的配置
*注*：如果是数据，则优先使用自身的。如果是钩子函数，则自身的和公用的都会触发
```
//新建js文件
export const common={
    method:{},
    created(){},
}
//在需要的组件中引入
import{common} from"
export default{
    data(){return{}},
    mixins:[common] //必须用数组
}
```
## 插件
```
export default{
    install(Vue){ //第一个形参为vue构造函数
    console.log("ok")
    }
}
//main.js引入
import plugin.....
Vue.use(plugin)
```
## 路由
1. 安装npm install vue-router@3 --save
2. 使用
```
//创建一个配置的路由的js文件
import Vue from 'vue' //vue-router依赖vue，必须先引入vue
import VueRouter from 'vue-router'
import Test from '../components/test.vue' //引入组件
Vue.use(VueRouter) //全局注册
let router = new VueRouter({
    routes: [{
        path: '/test',
        name: 'test',
        component: Test
    },]
})
export { router }
//在main.js中引入vue-router
import { router } from "./router";
new Vue({
    router,
    render: h => h(App),
  }).$mount('#app')
//在App.vue中设置</router-view>用来定义路由指向的组件显示的位置，此为必须属性，若是嵌套路由，是需要在父级写一个</router-view>即可
 <router-view></router-view>
 //上述必须手动切换网址，可设置如下标签作为点击跳转链接
 <router-link to="/test">Test</router-link>
 //动态路由的params方法，需要修改路由配置项。可在Test2组件的页面中通过this.$route.params获取id
  {
        path: '/test2/:id', //:id为占位符
        name: 'test2',
        component:()=>import('../components/test2.vue') //此处是路由的懒加载，点击后才会加载界面，节省性能
    },
    <router-link to="/test2/101">Test2</router-link>
 //动态路由的query方法，无需修改路由配置项。可在Test2组件的页面中通过this.$route.query获取id
    <router-link to="/test2?id=101">Test2</router-link>
//上述标签也可写成如下形式
<router-link :to="{ name: 'test3', params: { id: 110 } }">Test3</router-link>
//编程式路由
this.$router.push("/detail") //path跳转
this.$router.replace("/detail") //替换当前路径
this.$router.go(-1) //后退一步
this.$router.push('Detail') //name跳转
this.$router.push({path:'/detail',query:{id:item.mId}}); //对象跳转
//对象跳转时name,path与query,params有四种组合，唯独path和params不能共存，会自动忽略params
```
*补充*实例化时，使用 linkActiveClass:'active'定义已激活路由的类名
```
var router=new VueRouter({
    //挂载的路由表
    //routes:routes
    routes,
    //自定义选中的类名
    linkActiveClass:'active'

})
```
*补充*使用`<keep-alive>`使当前路由页面缓存，在切走又切回来的时候保留input框的内容等.但是会使得created不触发
```
//include用来指定需要缓存的组件名（必须在export中输出name属性）
<keep-alive include="libai"> //也可以写成数组（注意冒号） :include=['libai','dufu']
      <router-view></router-view>
</keep-alive>
```
3. 子路由
```
  {
    path: '/info',
    name: 'Info',
    redirect: '/info/base',
    component: () => import("../views/Info.vue"),
    children: [
      {
        path: '/info/base',
        name: 'Base',
        component: () => import("../components/Base.vue")
      },
      {
        path: '/info/more',
        name: 'More',
        component: () => import("../components/More.vue")
      },]
  }
```
4. 路由守卫
```
//全局守卫，beforeEach 和 afterEach
router.beforeEach((to, from, next) => { 
    // 里面三个参数  to代表我们将要跳转的路径
    // from 代表从那个路径跳转过来 就是上一个路径
    // next代表 守卫可以通过next控制下一步的跳转 如果写了前置守卫 一定要添加next()到下一步 
    // next() 或next({name:"user",params:{id:1}})
})
router.afterEach((to, from) => {
})
//路由守卫，写在路由配置里
 beforeEnter: (to, from, next) => {
      next()
    }
//组件守卫，写在组件里
beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建,可通过next传入形参vm获取组件实例
    next(vm=>{})
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
```
5. 路由元信息
```
//写在路由配置中，可供程序员在路由守卫中访问的自定义信息
{
          path: 'bar',
          component: Bar,
          meta: { requiresAuth: true }
        }
```
## axios
1. 安装
npm install axios --save
相应组件中import axios from 'axios'
若不想每个组件都引入axios,可以在main.js中引入axios,并赋值给vue原型，
Vue.prototype.$axios=axios;
2. 使用
```
//get请求
axios.get('http://bufantec.com',{params:{start:1,limit:5}})
.then((res)=>console.log(res))
.catch((err)=>console.log(err);
//post请求
axios.post('http://bufantec.com',{start:1,limit:5}) //直接写对象，不要嵌套params属性
.then((res)=>console.log(res))
.catch((err)=>console.log(err);
//axios默认的content-type为json，如果后台要求‘application/x-www-form-urlencoded’，需要转换
//1. 使用URLSearchParams
 let obj = { username: "litaibai", password: "ghjjjj" };
    this.$axios
      .post(
        "http://www.bufantec.com/api/test/user/save",
        new URLSearchParams(obj).toString()
      )
      .then((res) => console.log(res))
//2. 使用qs.stringfy()
npm install qs --save
import qs from 'qs'
 let obj = { username: "litaibai", password: "ghjjjj" };
    this.$axios
      .post(
        "http://www.bufantec.com/api/test/user/save",
        qs.stringfy(obj)
      )
      .then((res) => console.log(res))
//axios的配置
axios.defaults.baseURL = 'http://localhost:3000';//这样写网址的时候就不用写前面公共部分了
axios.defaults.timeout = 2500 //超时后自动取消
```
3. axios拦截器
```
//请求拦截器
axios.interceptors.request.use((config)=>{
    concole.log(config);
    config.data=qs.stringfy(config.data);//可以在这里统一对post请求的参数处理
    return config;//必须return出去config，不然报错
},(err)=>{
    return Promise.reject(error);
})
//响应拦截器
axios.interceptors.response.use((res)=>{
return res.data;//非必须，可以对返回的数据进行过滤
})
```
4. axios封装
## vuex
Vuex 是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间数据的共享。
1. 安装
可以在创建项目时直接勾选，也可以npm安装
npm i vuex@3 --S //vue2最多支持vuex3的版本
2. 使用
```
//新建vuex文件夹下index.js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
const store = new Vuex.Store({
    state: {
        name: 'libai',
    }
})
export { store }
//在main.js中引入,并挂载到Vue实例
import { store } from './vuex'
new Vue({
  router, store,
  render: h => h(App),
}).$mount('#app')
//在所有组件中就可以通过this.$store.state.name访问相应属性
```
3. 指南
```
//mutations中放置更新state中数据的方法
  mutations: {
      //此处val对应下文commit中的val
        updateAge(state, val) {
            state.age += val;
        }
    },
//调用mutations中的方法需要使用commit,且只能传递一个参数，该参数对应上述的val,val可以是数组或对象，val又称为载荷
this.$store.commit("updateAge", val);
//getter中放置计算属性
  getters: {
        getAge(state) {
            return state.age + 6;
        }
    }
//使用时
this.$store.getters.getAge
//actions,与mutations类似，执行异步方法
actions:{
    addAge(context,val){
        setTimeout(()=>{
context.commit('updateAge',val)
        },1000)
    }
}
//使用actions时，需要时使用this.$store.dispatch('addAge',2)
```
4. vuex的模块化
```
//配置
const testStore={
    namespaced:true, //必须开启,否则后面对不到值
    state:{},
    getters:{},
}
export default new Vuex.Store({
    modules: {
        a: testStore, b: testStore2
    }
})
//读取（均有两种方法）
this.$store.state.a.name
...mapState('a',['name'])
this.$store.getters['a/getAge']
...mapGetters('a',['getAge'])
this.$store.commit('a/updateAge',val)
...mapMutations('a',['updateAge])
this.$store.dispatch('a/addAge',val)
...mapActions('a',['addAge])
```
# 微信小程序
密钥:0cb13b9a9d20b5c0d6e28752e7453de3
## 几个注意点
1. 组件引入不加文件后缀
2. 背景图片不支持本地图片
3. json文件设置"component":"true"后才能组件传值
4. for循环时绑定key值不需要加{{}},直接wx:key="id"，不要用"{{item.id}}"。如果数据不是数组嵌套对象的格式，而是单层的数组，可用wx:key="*this"
5. 绑定事件时直接bindtap="myevent",不加花括号
6. *面试*登录流程图
7. observer只能在组件中使用
## 混入
```
export default  Behavior({
  methods: {
    testevent(){
      console.log("ok");
      this.triggerEvent("testevent","libai")
    }
      }
})
//在需要的组件引入（必须相对路径），import mixin from "../../mixins/mixin.js"
Component({
  behaviors: [mixin],
  })
```
## 路由跳转
1. 自定义导航栏
在app.json中配置
```
 "tabBar": {
    "color": "#a9b7b7",
    "selectedColor": "#d81e06",
    "borderStyle": "white",
    "list": [
      {
        "iconPath": "/static/首页.png",
        "selectedIconPath": "/static/首页激活.png",
        "pagePath": "pages/index/index",
        "text": "首页"
      },
      {
        "iconPath": "/static/测试.png",
        "selectedIconPath": "/static/测试激活.png",
        "pagePath": "pages/test/test",
        "text": "测试"
      }
    ]
  },
```
2. 几种路由跳转方式
    1. wx.navigateTo({url:""})只能跳转非tabbar页面，保留当前页
    2. wx.switchTab({url:""})只能跳转tabbar页面，清除所有页
    3. wx.reLaunch({url:""})可以跳转tabbar和非tabbar页面，清除所有页
    4. wx.redirectTo({url:""})只能跳转非tabbar页面，关闭当前页
    5. wx.navigateBack({delta:2}),关闭当前页面，返回上一层或多层，可在之前调用`console.log( getCurrentPages())`查看层数再做跳转
    6. `<navigator url="pages/logs/index" open-type="navigate">跳转</navigator>`
    `<navigator delta=2 open-type="navigateBack">跳转</navigator>`
# react
1. antd按需引入配置
先下载craco
```
"scripts": {
    "start": "craco start",
    "build": "craco build",
    "test": "craco test",
    "eject": "react-scripts eject"
  },
//craco.config.js配置具体的修改规则
module.exports = {
    babel: {//支持装饰器
        plugins: [
            [
                "import",
                {
                    "libraryName": "antd",
                    "libraryDirectory": "es",
                    "style": 'css' //设置为true即是less 这里用的是css
                }
            ]
        ]
    },
};
```
## 生命周期
1. 初始化阶段：由ReactDom.render()触发
    1. constructor()
    2. componentWillMount()
    3. render()
    4. componentDidMount()
2. 更新阶段：由组件内部this.setState()或组件重新render()触发
    1. shouldComponentUpdate()
    2. componentWillUpdate()
    3. render()
    4. componentDidUpdate()
3. 卸载组件：由ReactDom.unmountComponentAtNode()触发
    1. componentWillUnmount()
## 组件传值
1. 批量传值
`<Test {...this.state.item}>`
2. setState更新数据是异步的
2. pubsub-js
```
//安装
import PubSub from 'pubsub-js';
//接受值的组件。其中msg为消息名，没啥用的参数。
componentDidMount() {
        this.token = PubSub.subscribe('search', (msg, data) => {
            this.setState(data)
        })
    }
componentWillUnmount() {
        PubSub.unsubscribe(this.token)
    }
//在传值的组件
PubSub.publish("search", {
                isLoading: false,
                userlist: res.data.items
            })
```
## 路由
```
cnpm i react-ruter-dom@5 --So
//使用
import { Link,NavLink, Route,Routes, Navigate，BrowserRouter,useRoutes } from "react-router-dom"
<BrowserRouter>
        <div className="App">
          <Link to="/search">search</Link>
          <Route path="/search" element={<Search>}></Route>
        </div>
</BrowserRouter>
//多个<Route>时需要用<Routes>包裹
//重定向,replace用于指定跳转模式是push还是replace,默认为true
 <Route path="/" element={<Navigate to="/about" replace={true}>}></Route>
//指定激活样式,end属性为子路由激活的时候不激活父路由的高亮
<NavLink end className={(a)=>a.isActive? "active highLight":"">about</NavLink>
//路由表
const element=useRoutes([
    {path:"/about",
    element:<About/>,
    children:[
        {
            path:"news",
            element:<News/>
        }
    ]}
])
//路由params传参
import {useParams} from "react-router-dom"
const {id}=useParams()
//路由search传参
import {useSearchParams} from "react-router-dom"
const [search,setSearch]=useSearchParams()
console.log(search.get('id'))
//直接插值语法替代原<Route>标签。如果是子路由界面，使用<Outlet/>
{element}
//编程式路由
goTo = () => {
        this.props.history.push("/search/list?id=9")
    }
//将一般组件变为路由组件
import {withRouter } from "react-router-dom"
class Header extends component{}
export default withRouter(Header)
//HashRouter和BrowserRouter最大的区别在于HashRouter刷新页面后会丢失state参数
//懒加载
import {lazy,Suspense} from 'react'
const Test=lazy(()=>import('./components/test'))
<Suspense fallback={<h4>加载中</h4>}>
     <Route path="/test" component={Test}></Route>
<Suspense>
```
## redux
1. 原生redux
```
//创建redux文件夹，内置test_reducer.js和store.js
//在test_reducer.js中
//由于reducer初始化时preState为undefined,故此处可为其指定默认值
//注：reducer必须是一个纯函数（同样的输入得到同一个值，不改写输入值，所以一般用解构赋值实现数组的增加，而不是用push方法）
//注：当preState是引用类型时，必须创建一个新的引用类型数据才算修改，否则无法识别preState的值的变更
export default function testReducer(preState=0,action){
const {type,data}=action
switch(type){
    case 'increment': return preState+data;
    case 'decrement': return preState-data;
    default: preState;
}
}
//在store.js中
import {createStore} from 'redux'
import testReducer from './test_reducer'
export default createStore(testReducer)
//调用 store
 add = () => {
        store.dispatch({type:'increment',data:1})
    }
    render() {
        return (
            <div>{store.getState()} <button onClick={this.add}></button></div>
        )
    }
//redux不会重新渲染数据，需要手动监听.可在入口文件全局监听，也可在单文件中监听。
store.subscribe(() => {
  root.render(
    <App />
  );
})
```
2. react-redux
```
npm i react-redux --S
import { connect } from "react-redux"
export default connect(state => ({ state }), //映射store中的状态
    { increment, addPerson } //映射actions
)(Count)
//其中increment和addPerson为
const increment = (data) => ({ type: "increment", data })
export { increment }
//使用上述connect处理后的组件时，需要手动传入store
<Count store={store}></Count>
//也可以借助Provider批量传入
import {Provider} from "react-redux"
<Provider store={store}></Provider>
//混合多个reducer
import { legacy_createStore as createStore, combineReducers } from 'redux'
const allReducer = combineReducers({
    count: countReducer,
    person: personReducer
})
export default createStore(allReducer);
//以后取值的时候就得用store.getState().count
```
2. redux-devtools-extension
```
//谷歌商店安装插件，npm安装
import {composeWithDevTools} from "redux-devtools-extension"
//如有中间件则作为composeWithDevTools的参数传进去，否则不传
createStore(allReducer,composeWithDevTools(applyMiddleware(thunk)))
```